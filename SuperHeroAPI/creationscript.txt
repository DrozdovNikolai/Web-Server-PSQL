BEGIN;

ALTER DATABASE superherodb SET search_path TO public, ums;




CREATE TABLE IF NOT EXISTS ums.ums_user_auth_tokens
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    user_id integer NOT NULL,
    token text COLLATE pg_catalog."default" NOT NULL,
    expiration timestamp with time zone NOT NULL,
    is_revoked boolean NOT NULL DEFAULT false,
    revoked_at timestamp with time zone,
    CONSTRAINT user_auth_tokens_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_users
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    username text COLLATE pg_catalog."default" NOT NULL,
    password_hash text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ums_users_pkey PRIMARY KEY (id),
    CONSTRAINT ums_unique_username UNIQUE (username)
);

CREATE TABLE IF NOT EXISTS ums.ums_user_role
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    user_id integer NOT NULL,
    role_id integer NOT NULL,
    CONSTRAINT pk_user_role PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_roles
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    role_name text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ums_roles_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_globalpermissions (
    permission_id SERIAL PRIMARY KEY,
    role_id INTEGER,
    schema_name TEXT NOT NULL,
    grant_create_db BOOLEAN NOT NULL DEFAULT FALSE,  -- CREATE new schemas
    grant_create_obj BOOLEAN NOT NULL DEFAULT FALSE, -- CREATE objects in schema
    grant_usage_schema BOOLEAN NOT NULL DEFAULT FALSE, -- USAGE on schema
    grant_update_tbl BOOLEAN NOT NULL DEFAULT FALSE,
    grant_delete_tbl BOOLEAN NOT NULL DEFAULT FALSE,
    grant_select_tbl BOOLEAN NOT NULL DEFAULT FALSE, -- SELECT on tables
    grant_insert_tbl BOOLEAN NOT NULL DEFAULT FALSE, -- INSERT on tables
    grant_truncate_tbl BOOLEAN NOT NULL DEFAULT FALSE, -- TRUNCATE on tables
    grant_references_tbl BOOLEAN NOT NULL DEFAULT FALSE, -- REFERENCES on tables
    grant_trigger_tbl BOOLEAN NOT NULL DEFAULT FALSE, -- TRIGGER on tables
    grant_usage_seq BOOLEAN NOT NULL DEFAULT FALSE, -- USAGE on sequences
    grant_select_seq BOOLEAN NOT NULL DEFAULT FALSE, -- SELECT on sequences
    grant_update_seq BOOLEAN NOT NULL DEFAULT FALSE, -- UPDATE on sequences
    grant_execute_func BOOLEAN NOT NULL DEFAULT FALSE, -- EXECUTE on functions
    CONSTRAINT uq_role_schema UNIQUE (role_id, schema_name),
    CONSTRAINT fk_role_id FOREIGN KEY (role_id)
        REFERENCES ums.ums_roles (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
        NOT VALID
);

CREATE TABLE IF NOT EXISTS ums.ums_permissions
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    role_id integer NOT NULL,
    table_name text COLLATE pg_catalog."default" NOT NULL,
    operation integer NOT NULL,
    CONSTRAINT pk_permissions PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_function_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    function_name character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT function_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_procedure_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    procedure_name character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT procedure_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_table_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    tablename character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT table_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_trigger_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    trigger_name character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT trigger_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_request_logs
(
    id serial NOT NULL,
    user_id integer,
    path text COLLATE pg_catalog."default" NOT NULL,
    method character varying(10) COLLATE pg_catalog."default" NOT NULL,
    query_string text COLLATE pg_catalog."default" NOT NULL,
    request_body text COLLATE pg_catalog."default" NOT NULL,
    response_body text COLLATE pg_catalog."default" NOT NULL,
    status_code integer NOT NULL,
    request_time timestamp without time zone NOT NULL,
    response_time timestamp without time zone NOT NULL,
    duration interval NOT NULL,
    ip_address character varying(45) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ums_request_logs_pkey PRIMARY KEY (id)
);

-- Create the Containers table for managing Kubernetes deployments
CREATE TABLE IF NOT EXISTS ums.ums_containers
(
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL,
    db_host VARCHAR(255) NOT NULL,
    db_port VARCHAR(10) NOT NULL,
    db_name VARCHAR(255) NOT NULL,
    db_user VARCHAR(255) NOT NULL,
    db_password VARCHAR(255) NOT NULL,
    db_username VARCHAR(255) NOT NULL,
    db_password_user VARCHAR(255) NOT NULL,
    external_url VARCHAR(255) NOT NULL DEFAULT '',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Grant necessary permissions for the containers table
--INSERT INTO ums.ums_permissions (role_id, table_name, operation)
--SELECT id, 'ums.containers', 10 -- ALL PRIVILEGES
--FROM ums.ums_roles 
--WHERE role_name = 'superadmin'
--ON CONFLICT DO NOTHING;

ALTER TABLE IF EXISTS ums.ums_user_auth_tokens
    ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;
CREATE INDEX IF NOT EXISTS user_auth_tokens_pkey
    ON ums.ums_user_auth_tokens(id);


ALTER TABLE IF EXISTS ums.ums_user_role
    ADD CONSTRAINT fk_user_role_roles_role_id FOREIGN KEY (role_id)
    REFERENCES ums.ums_roles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_UserRole_RoleId"
    ON ums.ums_user_role(role_id);


ALTER TABLE IF EXISTS ums.ums_user_role
    ADD CONSTRAINT fk_user_role_users_user_id FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_UserRole_UserId"
    ON ums.ums_user_role(user_id);





ALTER TABLE IF EXISTS ums.ums_permissions
    ADD CONSTRAINT fk_role_id FOREIGN KEY (role_id)
    REFERENCES ums.ums_roles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS ums.ums_function_user
    ADD CONSTRAINT function_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_procedure_user
    ADD CONSTRAINT procedure_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_table_user
    ADD CONSTRAINT table_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_trigger_user
    ADD CONSTRAINT trigger_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_request_logs
    ADD CONSTRAINT fk_user FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_request_logs_user_id
    ON ums.ums_request_logs(user_id);



CREATE OR REPLACE FUNCTION ums.add_permission_to_role()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    schema_name TEXT := 'public'; -- ����� �� ���������
    table_name TEXT;
    column_name TEXT;
    full_table_ref TEXT;
BEGIN
    -- �������� ��� ���� �� role_id
    SELECT j.role_name INTO role_name FROM ums.ums_roles j WHERE id = NEW.role_id;

    -- ���������, ���� �� ����� � ����� �������
    IF POSITION('.' IN NEW.table_name) > 0 THEN
        -- table_name �������� 'schema.table' ��� 'table.column'
        IF NEW.operation IN (0,1,2) AND POSITION('.' IN split_part(NEW.table_name, '.', 2)) > 0 THEN
            -- ������: table.column (��� �����)
            table_name := split_part(NEW.table_name, '.', 1);
            column_name := split_part(NEW.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        ELSE
            -- ������: schema.table
            schema_name := split_part(NEW.table_name, '.', 1);
            table_name := split_part(NEW.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        END IF;
    ELSE
        -- ������ ��� �������
        table_name := NEW.table_name;
        full_table_ref := format('%I.%I', schema_name, table_name);
    END IF;

    -- ��������� ����������
    IF NEW.operation = 0 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('GRANT INSERT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('GRANT INSERT ON TABLE %s TO %I', full_table_ref, role_name);
        END IF;
    ELSIF NEW.operation = 1 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('GRANT SELECT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('GRANT SELECT ON TABLE %s TO %I', full_table_ref, role_name);
        END IF;
    ELSIF NEW.operation = 2 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('GRANT UPDATE (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('GRANT UPDATE ON TABLE %s TO %I', full_table_ref, role_name);
        END IF;
    ELSIF NEW.operation = 3 THEN
        EXECUTE format('GRANT DELETE ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 4 THEN
        EXECUTE format('GRANT ALTER ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 5 THEN
        EXECUTE format('GRANT DROP ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 6 THEN
        EXECUTE format('GRANT TRIGGER ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 7 THEN
        EXECUTE format('GRANT CREATE ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 8 THEN
        EXECUTE format('GRANT VACUUM ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 9 THEN
        EXECUTE format('GRANT ANALYZE ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 10 THEN
        EXECUTE format('GRANT ALL PRIVILEGES ON TABLE %s TO %I', full_table_ref, role_name);
    END IF;

    RETURN NEW;
END;
$BODY$;



ALTER FUNCTION ums.add_permission_to_role()
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION ums.create_role_from_roles_table()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Check if the role_name is not null
    IF NEW.role_name IS NOT NULL THEN
        -- Create the role with the provided name
        EXECUTE format('CREATE ROLE %I', NEW.role_name);
    END IF;
    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION ums.create_role_from_roles_table()
    OWNER TO postgres;


CREATE OR REPLACE FUNCTION ums.delete_permission_from_role()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    schema_name TEXT := 'public'; -- ����� �� ���������
    table_name TEXT;
    column_name TEXT;
    full_table_ref TEXT;
BEGIN
    -- �������� ��� ���� �� role_id
    SELECT j.role_name INTO role_name FROM ums.ums_roles j WHERE id = OLD.role_id;

    -- ���������� ������: column-level ��� schema.table
    IF POSITION('.' IN OLD.table_name) > 0 THEN
        -- ���� ������ ����� �������� ��� ���� ����� � ������ ��� table.column
        IF OLD.operation IN (0,1,2) AND POSITION('.' IN split_part(OLD.table_name, '.', 2)) > 0 THEN
            -- column-level
            table_name := split_part(OLD.table_name, '.', 1);
            column_name := split_part(OLD.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        ELSE
            -- schema.table
            schema_name := split_part(OLD.table_name, '.', 1);
            table_name := split_part(OLD.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        END IF;
    ELSE
        -- ������ ��� �������, ��� �����
        table_name := OLD.table_name;
        full_table_ref := format('%I.%I', schema_name, table_name);
    END IF;

    -- ����� ����
    IF OLD.operation = 0 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('REVOKE INSERT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('REVOKE INSERT ON TABLE %s FROM %I', full_table_ref, role_name);
        END IF;
    ELSIF OLD.operation = 1 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('REVOKE SELECT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('REVOKE SELECT ON TABLE %s FROM %I', full_table_ref, role_name);
        END IF;
    ELSIF OLD.operation = 2 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('REVOKE UPDATE (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('REVOKE UPDATE ON TABLE %s FROM %I', full_table_ref, role_name);
        END IF;
    ELSIF OLD.operation = 3 THEN
        EXECUTE format('REVOKE DELETE ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 4 THEN
        EXECUTE format('REVOKE ALTER ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 5 THEN
        EXECUTE format('REVOKE DROP ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 6 THEN
        EXECUTE format('REVOKE TRIGGER ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 7 THEN
        EXECUTE format('REVOKE CREATE ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 8 THEN
        EXECUTE format('REVOKE VACUUM ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 9 THEN
        EXECUTE format('REVOKE ANALYZE ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 10 THEN
        EXECUTE format('REVOKE ALL PRIVILEGES ON TABLE %s FROM %I', full_table_ref, role_name);
    END IF;

    RETURN OLD;
END;
$BODY$;


ALTER FUNCTION ums.delete_permission_from_role()
    OWNER TO postgres;

-- FUNCTION: ums.delete_role_from_roles_table()
CREATE OR REPLACE FUNCTION ums.delete_role_from_roles_table()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Drop the role if it exists
    EXECUTE format('DROP ROLE IF EXISTS %I', OLD.role_name);
    RETURN OLD;
END;
$BODY$;

ALTER FUNCTION ums.delete_role_from_roles_table()
    OWNER TO postgres;

-- FUNCTION: ums.update_global_role_permissions()
CREATE OR REPLACE FUNCTION ums.update_global_role_permissions()
RETURNS trigger
LANGUAGE plpgsql
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    r RECORD;
BEGIN
    -- �������� ��� ���� �� role_id
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = NEW.role_id;

    -- CREATE ON DATABASE (������ ���� ���, �� ������� �� ����)
    IF OLD.create_table_grant <> NEW.create_table_grant THEN
        IF OLD.create_table_grant THEN
            EXECUTE format('REVOKE CREATE ON DATABASE %I FROM %I', 'superherodb', role_name);
        END IF;
        IF NEW.create_table_grant THEN
            EXECUTE format('GRANT CREATE ON DATABASE %I TO %I', 'superherodb', role_name);
        END IF;
    END IF;

    -- ����� ���� ���������������� ����
    FOR r IN
        SELECT schema_name
        FROM information_schema.schemata
        WHERE schema_name NOT IN ('pg_catalog', 'information_schema')
    LOOP
        -- UPDATE ON TABLES
        IF OLD.update_table_grant <> NEW.update_table_grant THEN
            IF OLD.update_table_grant THEN
                EXECUTE format('REVOKE UPDATE ON ALL TABLES IN SCHEMA %I FROM %I', r.schema_name, role_name);
            END IF;
            IF NEW.update_table_grant THEN
                EXECUTE format('GRANT UPDATE ON ALL TABLES IN SCHEMA %I TO %I', r.schema_name, role_name);
            END IF;
        END IF;

        -- DELETE ON TABLES
        IF OLD.delete_table_grant <> NEW.delete_table_grant THEN
            IF OLD.delete_table_grant THEN
                EXECUTE format('REVOKE DELETE ON ALL TABLES IN SCHEMA %I FROM %I', r.schema_name, role_name);
            END IF;
            IF NEW.delete_table_grant THEN
                EXECUTE format('GRANT DELETE ON ALL TABLES IN SCHEMA %I TO %I', r.schema_name, role_name);
            END IF;
        END IF;

        -- CREATE ON SCHEMA
        IF OLD.create_grant <> NEW.create_grant THEN
            IF OLD.create_grant THEN
                EXECUTE format('REVOKE CREATE ON SCHEMA %I FROM %I', r.schema_name, role_name);
            END IF;
            IF NEW.create_grant THEN
                EXECUTE format('GRANT CREATE ON SCHEMA %I TO %I', r.schema_name, role_name);
            END IF;
        END IF;

        -- ������� USAGE ����� ��������� �� ������� (����� �� �������, �� ����� ��������)
    END LOOP;

    RETURN NEW;
END;
$BODY$;


ALTER FUNCTION ums.update_global_role_permissions()
    OWNER TO postgres;

-- FUNCTION: ums.update_role_from_roles_table()
CREATE OR REPLACE FUNCTION ums.update_role_from_roles_table()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Check if the role_name has been modified
    IF OLD.role_name <> NEW.role_name THEN
        -- Check if the old role exists
        PERFORM 1 FROM pg_roles WHERE rolname = OLD.role_name;
        IF FOUND THEN
            -- Rename the old role to the new role
            EXECUTE format('ALTER ROLE %I RENAME TO %I', OLD.role_name, NEW.role_name);
        END IF;
    END IF;
    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION ums.update_role_from_roles_table()
    OWNER TO postgres;

-- FUNCTION: ums.update_role_permissions()
CREATE OR REPLACE FUNCTION ums.update_role_permissions()
RETURNS trigger
LANGUAGE plpgsql
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    schema_name TEXT := 'public'; -- �� ���������
    table_name TEXT;
    column_name TEXT;
    full_table_ref TEXT;
BEGIN
    -- �������� ��� ����
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = NEW.role_id;

    -- ������ ���� operation ��� table_name ����������
    IF OLD.operation <> NEW.operation OR OLD.table_name <> NEW.table_name THEN

        ---------------------------------------------------------------------
        -- 1. REVOKE ������ �����
        ---------------------------------------------------------------------
        -- ���������� �����, ������� � ������� �� OLD.table_name
        column_name := NULL;
        IF POSITION('.' IN OLD.table_name) > 0 THEN
            IF OLD.operation IN (0,1,2) AND POSITION('.' IN split_part(OLD.table_name, '.', 2)) > 0 THEN
                -- table.column
                table_name := split_part(OLD.table_name, '.', 1);
                column_name := split_part(OLD.table_name, '.', 2);
            ELSE
                -- schema.table
                schema_name := split_part(OLD.table_name, '.', 1);
                table_name := split_part(OLD.table_name, '.', 2);
            END IF;
        ELSE
            table_name := OLD.table_name;
        END IF;
        full_table_ref := format('%I.%I', schema_name, table_name);

        IF OLD.operation = 0 AND column_name IS NOT NULL THEN
            EXECUTE format('REVOKE INSERT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSIF OLD.operation = 1 AND column_name IS NOT NULL THEN
            EXECUTE format('REVOKE SELECT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSIF OLD.operation = 2 AND column_name IS NOT NULL THEN
            EXECUTE format('REVOKE UPDATE (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            CASE OLD.operation
                WHEN 0 THEN EXECUTE format('REVOKE INSERT ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 1 THEN EXECUTE format('REVOKE SELECT ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 2 THEN EXECUTE format('REVOKE UPDATE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 3 THEN EXECUTE format('REVOKE DELETE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 4 THEN EXECUTE format('REVOKE ALTER ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 5 THEN EXECUTE format('REVOKE DROP ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 6 THEN EXECUTE format('REVOKE TRIGGER ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 7 THEN EXECUTE format('REVOKE CREATE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 8 THEN EXECUTE format('REVOKE VACUUM ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 9 THEN EXECUTE format('REVOKE ANALYZE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 10 THEN EXECUTE format('REVOKE ALL PRIVILEGES ON TABLE %s FROM %I', full_table_ref, role_name);
            END CASE;
        END IF;

        ---------------------------------------------------------------------
        -- 2. GRANT ����� �����
        ---------------------------------------------------------------------
        schema_name := 'public'; -- ���������� ����� �� ���������
        column_name := NULL;

        IF POSITION('.' IN NEW.table_name) > 0 THEN
            IF NEW.operation IN (0,1,2) AND POSITION('.' IN split_part(NEW.table_name, '.', 2)) > 0 THEN
                -- table.column
                table_name := split_part(NEW.table_name, '.', 1);
                column_name := split_part(NEW.table_name, '.', 2);
            ELSE
                -- schema.table
                schema_name := split_part(NEW.table_name, '.', 1);
                table_name := split_part(NEW.table_name, '.', 2);
            END IF;
        ELSE
            table_name := NEW.table_name;
        END IF;
        full_table_ref := format('%I.%I', schema_name, table_name);

        IF NEW.operation = 0 AND column_name IS NOT NULL THEN
            EXECUTE format('GRANT INSERT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSIF NEW.operation = 1 AND column_name IS NOT NULL THEN
            EXECUTE format('GRANT SELECT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSIF NEW.operation = 2 AND column_name IS NOT NULL THEN
            EXECUTE format('GRANT UPDATE (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            CASE NEW.operation
                WHEN 0 THEN EXECUTE format('GRANT INSERT ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 1 THEN EXECUTE format('GRANT SELECT ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 2 THEN EXECUTE format('GRANT UPDATE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 3 THEN EXECUTE format('GRANT DELETE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 4 THEN EXECUTE format('GRANT ALTER ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 5 THEN EXECUTE format('GRANT DROP ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 6 THEN EXECUTE format('GRANT TRIGGER ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 7 THEN EXECUTE format('GRANT CREATE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 8 THEN EXECUTE format('GRANT VACUUM ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 9 THEN EXECUTE format('GRANT ANALYZE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 10 THEN EXECUTE format('GRANT ALL PRIVILEGES ON TABLE %s TO %I', full_table_ref, role_name);
            END CASE;
        END IF;
    END IF;

    RETURN NEW;
END;
$BODY$;


ALTER FUNCTION ums.update_role_permissions()
    OWNER TO postgres;

-- Создание или обновление триггеров для таблиц
CREATE OR REPLACE TRIGGER tr_create_role_from_roles_table
    AFTER INSERT
    ON ums.ums_roles
    FOR EACH ROW
    EXECUTE FUNCTION ums.create_role_from_roles_table();

CREATE OR REPLACE TRIGGER tr_update_role_from_roles_table
    AFTER UPDATE
    ON ums.ums_roles
    FOR EACH ROW
    EXECUTE FUNCTION ums.update_role_from_roles_table();

CREATE OR REPLACE TRIGGER tr_delete_role_from_roles_table
    BEFORE DELETE
    ON ums.ums_roles
    FOR EACH ROW
    EXECUTE FUNCTION ums.delete_role_from_roles_table();

CREATE OR REPLACE TRIGGER tr_add_permission_to_role
    AFTER INSERT
    ON ums.ums_permissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.add_permission_to_role();

CREATE OR REPLACE TRIGGER tr_update_role_permissions
    AFTER UPDATE
    ON ums.ums_permissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.update_role_permissions();

CREATE OR REPLACE TRIGGER tr_delete_permission_from_role
    BEFORE DELETE
    ON ums.ums_permissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.delete_permission_from_role();


    CREATE OR REPLACE FUNCTION ums.select_roles(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT json_agg(row_to_json(t)) 
        FROM (
            SELECT
                id as roleid,
                role_name as rolename
            FROM ums.ums_roles
        ) t
    );
END;
$BODY$;

ALTER FUNCTION ums.select_roles()
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.update_roles(
	IN p_roleid integer,
	IN p_rolename text)
LANGUAGE 'plpgsql'
AS $BODY$

    BEGIN
        UPDATE ums.ums_roles
        SET  role_name = p_rolename
        WHERE id = p_roleid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_roles(integer, text)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.delete_roles(
	IN p_roleid integer)
LANGUAGE 'plpgsql'
AS $BODY$

    BEGIN
	DELETE from globalpermissions where roleid=p_roleid;
        DELETE from ums.ums_roles WHERE id = p_roleid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_roles(integer)
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION ums.select_globalpermissions()
RETURNS json
LANGUAGE 'plpgsql'
COST 100
VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT COALESCE(
            json_agg(row_to_json(t)), 
            '[]'::json  -- Если данных нет, возвращаем пустой JSON-массив
        )
        FROM (SELECT * FROM ums.ums_globalpermissions) t
    );
END;
$BODY$;

ALTER FUNCTION ums.select_globalpermissions()
    OWNER TO postgres;

CREATE OR REPLACE PROCEDURE ums.insert_globalpermissions(
    IN roleid integer,
    IN schema_name text,
    IN grant_create_db boolean,
    IN grant_create_obj boolean,
    IN grant_usage_schema boolean,
    IN grant_update_tbl boolean,
    IN grant_delete_tbl boolean,
    IN grant_select_tbl boolean,
    IN grant_insert_tbl boolean,
    IN grant_truncate_tbl boolean,
    IN grant_references_tbl boolean,
    IN grant_trigger_tbl boolean,
    IN grant_usage_seq boolean,
    IN grant_select_seq boolean,
    IN grant_update_seq boolean,
    IN grant_execute_func boolean
)
LANGUAGE plpgsql
AS $BODY$
BEGIN
    INSERT INTO ums.ums_globalpermissions (
        role_id,
        schema_name,
        grant_create_db,
        grant_create_obj,
        grant_usage_schema,
        grant_update_tbl,
        grant_delete_tbl,
        grant_select_tbl,
        grant_insert_tbl,
        grant_truncate_tbl,
        grant_references_tbl,
        grant_trigger_tbl,
        grant_usage_seq,
        grant_select_seq,
        grant_update_seq,
        grant_execute_func
    )
    VALUES (
        roleid,
        schema_name,
        grant_create_db,
        grant_create_obj,
        grant_usage_schema,
        grant_update_tbl,
        grant_delete_tbl,
        grant_select_tbl,
        grant_insert_tbl,
        grant_truncate_tbl,
        grant_references_tbl,
        grant_trigger_tbl,
        grant_usage_seq,
        grant_select_seq,
        grant_update_seq,
        grant_execute_func
    );
END;
$BODY$;


CREATE OR REPLACE PROCEDURE ums.update_globalpermissions(
	IN p_permissionid integer,
	IN p_roleid integer,
	IN p_schema_name text,
	IN p_grant_create_db boolean,
	IN p_grant_create_obj boolean,
	IN p_grant_usage_schema boolean,
	IN p_grant_update_tbl boolean,
	IN p_grant_delete_tbl boolean,
	IN p_grant_select_tbl boolean,
	IN p_grant_insert_tbl boolean,
	IN p_grant_truncate_tbl boolean,
	IN p_grant_references_tbl boolean,
	IN p_grant_trigger_tbl boolean,
	IN p_grant_usage_seq boolean,
	IN p_grant_select_seq boolean,
	IN p_grant_update_seq boolean,
	IN p_grant_execute_func boolean)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    -- Проверка, существует ли запись с данным permission_id
    IF EXISTS (SELECT 1 FROM ums.ums_globalpermissions WHERE permission_id = p_permissionid and schema_name=p_schema_name) THEN
        -- Если существует, выполняем обновление
        UPDATE ums.ums_globalpermissions
        SET role_id = p_roleid,
            schema_name = p_schema_name,
            grant_create_db = p_grant_create_db,
            grant_create_obj = p_grant_create_obj,
            grant_usage_schema = p_grant_usage_schema,
            grant_update_tbl = p_grant_update_tbl,
            grant_delete_tbl = p_grant_delete_tbl,
            grant_select_tbl = p_grant_select_tbl,
            grant_insert_tbl = p_grant_insert_tbl,
            grant_truncate_tbl = p_grant_truncate_tbl,
            grant_references_tbl = p_grant_references_tbl,
            grant_trigger_tbl = p_grant_trigger_tbl,
            grant_usage_seq = p_grant_usage_seq,
            grant_select_seq = p_grant_select_seq,
            grant_update_seq = p_grant_update_seq,
            grant_execute_func = p_grant_execute_func
        WHERE permission_id = p_permissionid and
	      schema_name = p_schema_name;
    ELSE
        -- Если записи нет, вставляем новую
        INSERT INTO ums.ums_globalpermissions (
            role_id,
            schema_name,
            grant_create_db,
            grant_create_obj,
            grant_usage_schema,
            grant_update_tbl,
            grant_delete_tbl,
            grant_select_tbl,
            grant_insert_tbl,
            grant_truncate_tbl,
            grant_references_tbl,
            grant_trigger_tbl,
            grant_usage_seq,
            grant_select_seq,
            grant_update_seq,
            grant_execute_func
        ) VALUES (
            p_roleid,
            p_schema_name,
            p_grant_create_db,
            p_grant_create_obj,
            p_grant_usage_schema,
            p_grant_update_tbl,
            p_grant_delete_tbl,
            p_grant_select_tbl,
            p_grant_insert_tbl,
            p_grant_truncate_tbl,
            p_grant_references_tbl,
            p_grant_trigger_tbl,
            p_grant_usage_seq,
            p_grant_select_seq,
            p_grant_update_seq,
            p_grant_execute_func
        );
    END IF;
END;
$BODY$;


CREATE OR REPLACE PROCEDURE ums.delete_globalpermissions(
	IN p_roleid integer,IN p_schema_name text)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        delete from ums.ums_globalpermissions WHERE roleid  = p_roleid and schema_name=p_schema_name;
    END;
    
$BODY$;



CREATE OR REPLACE FUNCTION ums.select_function_user()
RETURNS json
LANGUAGE plpgsql
COST 100
VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT COALESCE(
            json_agg(
                json_build_object(
                    'id', fu.id,
                    'functionname', fu.function_name,
                    'userid', fu.user_id,
                    'functiondefinition', pg_get_functiondef(p.oid)
                )
            ), '[]'::json
        )
        FROM ums.ums_function_user fu
        JOIN pg_proc p ON p.proname = split_part(fu.function_name, '.', 2)  -- Разделение по схеме и имени функции
        JOIN pg_namespace n ON p.pronamespace = n.oid
        WHERE n.nspname = 
            CASE 
                WHEN strpos(fu.function_name, '.') > 0 THEN split_part(fu.function_name, '.', 1)  -- Если схема указана
                ELSE 'public'  -- Если схема не указана, используем public
            END
    );
END;
$BODY$;

ALTER FUNCTION ums.select_function_user()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.update_function_user(
	IN p_id integer,
	IN p_user_id integer,
	IN p_function_name character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_function_user
        SET id = p_id, user_id = p_user_id, function_name = p_function_name
        WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_function_user(integer, integer, character varying)
    OWNER TO postgres;


CREATE OR REPLACE PROCEDURE ums.delete_function_user(
	IN p_id integer,
	IN p_functionname character varying
)
LANGUAGE plpgsql
AS $BODY$
DECLARE
    v_schema text := 'public';
    v_funcname text;
    v_full_name text;
BEGIN
    -- Если имя функции содержит схему, извлекаем схему и имя функции
    IF position('.' in p_functionname) > 0 THEN
        v_schema := split_part(p_functionname, '.', 1);
        v_funcname := split_part(p_functionname, '.', 2);
    ELSE
        v_funcname := p_functionname;
    END IF;

    -- Полное имя функции с экранированием
    v_full_name := format('%I.%I', v_schema, v_funcname);

    -- Удаляем функцию, если существует (предполагается, что сигнатура неизвестна)
    -- Это удалит все функции с таким именем вне зависимости от сигнатуры
    -- Лучше явно указать сигнатуру, если известно, чтобы избежать побочных эффектов
    EXECUTE format('DROP FUNCTION IF EXISTS %s CASCADE', v_full_name);

    -- Удаляем запись из таблицы
    DELETE FROM ums.ums_function_user WHERE id = p_id;
END;
$BODY$;
ALTER PROCEDURE ums.delete_function_user(integer, character varying)
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION ums.select_procedure_user()
RETURNS json
LANGUAGE plpgsql
COST 100
VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT COALESCE(
            json_agg(
                json_build_object(
                    'id', fu.id,
                    'procedure_name', fu.procedure_name,
                    'user_id', fu.user_id,
                    'procedure_definition', pg_get_functiondef(p.oid)
                )
            ), '[]'::json
        )
        FROM ums.ums_procedure_user fu
        JOIN pg_proc p ON p.proname = split_part(fu.procedure_name, '.', 2)  -- Разделение по схеме и имени процедуры
        JOIN pg_namespace n ON p.pronamespace = n.oid
        WHERE n.nspname = 
            CASE 
                WHEN strpos(fu.procedure_name, '.') > 0 THEN split_part(fu.procedure_name, '.', 1)  -- Если схема указана
                ELSE 'public'  -- Если схема не указана, используем public
            END
    );
END;
$BODY$;

ALTER FUNCTION ums.select_procedure_user()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.update_procedure_user(
	IN p_id integer,
	IN p_user_id integer,
	IN p_procedure_name character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_procedure_user
        SET id = p_id, user_id = p_user_id, procedure_name = p_procedure_name
        WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_procedure_user(integer, integer, character varying)
    OWNER TO postgres;

CREATE OR REPLACE PROCEDURE ums.delete_procedure_user(
	IN p_id integer,
	IN p_procedure_name character varying)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_schema text := 'public';
    v_procname text;
    v_full_name text;
BEGIN
    -- ��������� ���, ���� ������� �����
    IF position('.' in p_procedure_name) > 0 THEN
        v_schema := split_part(p_procedure_name, '.', 1);
        v_procname := split_part(p_procedure_name, '.', 2);
    ELSE
        v_procname := p_procedure_name;
    END IF;

    -- ���������� ������ ��� ��������� ��� ��������
    v_full_name := format('%I.%I', v_schema, v_procname);

    -- ������� ��������� (��������������, ��� � �� ��� ���������� ��� ��������� �����������)
    EXECUTE format('DROP PROCEDURE IF EXISTS %s', v_full_name);

    -- ������� ������ �� �������
    DELETE FROM ums.ums_procedure_user WHERE id = p_id;
END;
$BODY$;


ALTER PROCEDURE ums.delete_procedure_user(integer, character varying)
    OWNER TO postgres;


    
CREATE OR REPLACE FUNCTION ums.select_table_definition(table_name text)
  RETURNS text
  LANGUAGE plpgsql
AS $BODY$
DECLARE
  reg_oid        oid;
  schema_name    text;
  tbl_name       text;
  table_def      text := '';
  column_def     text;
  constraint_def text;
  comment_text   text;
  row_col        record;
  row_con        record;
  row_idx        record;
  row_comment    record;
BEGIN
  -- �������� OID, ����� � ��� �������
  SELECT (table_name::regclass)::oid,
         n.nspname,
         c.relname
    INTO reg_oid, schema_name, tbl_name
    FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
   WHERE c.oid = table_name::regclass;

  -- 1) ������ CREATE TABLE
  table_def := format(
    'CREATE TABLE %I.%I (%s',
    schema_name, tbl_name, E'\n'
  );

  -- 1.1) Columns
  FOR row_col IN
    SELECT
      a.attname,
      format_type(a.atttypid, a.atttypmod) AS data_type,
      pg_get_expr(ad.adbin, ad.adrelid)    AS default_value,
      a.attnotnull
    FROM pg_attribute a
    LEFT JOIN pg_attrdef ad
      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
    WHERE a.attrelid = reg_oid
      AND a.attnum > 0
      AND NOT a.attisdropped
    ORDER BY a.attnum
  LOOP
    column_def := format(
      '    %I %s%s%s,',
      row_col.attname,
      row_col.data_type,
      COALESCE(' DEFAULT ' || row_col.default_value, ''),
      CASE WHEN row_col.attnotnull THEN ' NOT NULL' ELSE '' END
    );
    table_def := table_def || column_def || E'\n';
  END LOOP;

  -- 1.2) Constraints (PK, UNIQUE, CHECK, EXCLUDE, FK)
  FOR row_con IN
    SELECT
      c.oid,
      c.conname,
      c.contype,
      c.condeferrable,
      c.condeferred,
      -- ��� CHECK
      pg_get_expr(c.conbin, c.conrelid) AS check_expr,
      -- ��� FK
      n2.nspname    AS ref_schema,
      c2.relname    AS ref_table,
      c.confmatchtype,
      c.confupdtype,
      c.confdeltype,
      -- ������ ������
      ARRAY(
        SELECT quote_ident(a2.attname)
        FROM unnest(c.conkey) AS ck(attnum)
        JOIN pg_attribute a2
          ON a2.attrelid = c.conrelid AND a2.attnum = ck.attnum
        ORDER BY array_position(c.conkey, ck.attnum)
      ) AS key_cols,
      ARRAY(
        SELECT quote_ident(a3.attname)
        FROM unnest(c.confkey) AS fk(attnum)
        JOIN pg_attribute a3
          ON a3.attrelid = c.confrelid AND a3.attnum = fk.attnum
        ORDER BY array_position(c.confkey, fk.attnum)
      ) AS ref_cols
    FROM pg_constraint c
    JOIN pg_class rel ON rel.oid = c.conrelid
    JOIN pg_namespace n ON n.oid = rel.relnamespace
    LEFT JOIN pg_class c2 ON c2.oid = c.confrelid
    LEFT JOIN pg_namespace n2 ON n2.oid = c2.relnamespace
    WHERE rel.oid = reg_oid
    ORDER BY c.contype DESC
  LOOP
    constraint_def := '    CONSTRAINT ' || quote_ident(row_con.conname) || ' ';

    IF row_con.contype = 'p' THEN
      constraint_def := constraint_def
        || 'PRIMARY KEY ('
        || array_to_string(row_con.key_cols, ', ')
        || ')';

    ELSIF row_con.contype = 'u' THEN
      constraint_def := constraint_def
        || 'UNIQUE ('
        || array_to_string(row_con.key_cols, ', ')
        || ')';

    ELSIF row_con.contype = 'c' THEN
      constraint_def := constraint_def
        || 'CHECK (' || row_con.check_expr || ')';

    ELSIF row_con.contype = 'x' THEN
      -- EXCLUDE ����� ������� ����� pg_get_constraintdef
      constraint_def := constraint_def
        || substring(
             pg_get_constraintdef(row_con.oid)
             FROM '^EXCLUDE.*'
           );

    ELSIF row_con.contype = 'f' THEN
      constraint_def := constraint_def
        || 'FOREIGN KEY ('
        || array_to_string(row_con.key_cols, ', ')
        || ') REFERENCES '
        || quote_ident(row_con.ref_schema) || '.' || quote_ident(row_con.ref_table)
        || '(' || array_to_string(row_con.ref_cols, ', ') || ')'
        -- MATCH
        || ' MATCH '
        || CASE row_con.confmatchtype
             WHEN 'f' THEN 'FULL'
             WHEN 'p' THEN 'PARTIAL'
             ELSE 'SIMPLE'
           END
        -- ON UPDATE
        || ' ON UPDATE '
        || CASE row_con.confupdtype
             WHEN 'a' THEN 'NO ACTION'
             WHEN 'r' THEN 'RESTRICT'
             WHEN 'c' THEN 'CASCADE'
             WHEN 'n' THEN 'SET NULL'
             WHEN 'd' THEN 'SET DEFAULT'
           END
        -- ON DELETE
        || ' ON DELETE '
        || CASE row_con.confdeltype
             WHEN 'a' THEN 'NO ACTION'
             WHEN 'r' THEN 'RESTRICT'
             WHEN 'c' THEN 'CASCADE'
             WHEN 'n' THEN 'SET NULL'
             WHEN 'd' THEN 'SET DEFAULT'
           END;
    END IF;

    -- DEFERRABLE / INITIALLY ...
    constraint_def := constraint_def
      || CASE WHEN row_con.contype <> 'x'  -- EXCLUDE ��� ������
              THEN
                ' '
                || CASE WHEN row_con.condeferrable THEN 'DEFERRABLE' ELSE 'NOT DEFERRABLE' END
                || ' '
                || CASE WHEN row_con.condeferred THEN 'INITIALLY DEFERRED' ELSE 'INITIALLY IMMEDIATE' END
              ELSE ''
         END
      || ',';

    table_def := table_def || constraint_def || E'\n';
  END LOOP;

  -- ������� ��������� ������� � ��������� CREATE TABLE
  table_def := regexp_replace(
    table_def,
    ',\s*\n$',
    E'\n',
    'm'
  ) || ');' || E'\n\n';

  -- 2) ����������� �� �������
  SELECT obj_description(reg_oid, 'pg_class') INTO comment_text;
  IF comment_text IS NOT NULL THEN
    table_def := table_def
      || format('COMMENT ON TABLE %I.%I IS %L;', schema_name, tbl_name, comment_text)
      || E'\n';
  END IF;

  -- 2.1) ����������� �� �������
  FOR row_comment IN
    SELECT a.attname, col_description(a.attrelid, a.attnum) AS comment
      FROM pg_attribute a
     WHERE a.attrelid = reg_oid
       AND a.attnum > 0
       AND NOT a.attisdropped
       AND col_description(a.attrelid,a.attnum) IS NOT NULL
  LOOP
    table_def := table_def
      || format(
           'COMMENT ON COLUMN %I.%I.%I IS %L;',
           schema_name, tbl_name, row_comment.attname,
           row_comment.comment
         ) || E'\n';
  END LOOP;
  table_def := table_def || E'\n';

  -- 3) �������
  FOR row_idx IN
    SELECT indexdef
      FROM pg_indexes
     WHERE schemaname = schema_name
       AND tablename  = tbl_name
     ORDER BY indexname
  LOOP
    table_def := table_def || row_idx.indexdef || ';' || E'\n';
  END LOOP;

  RETURN table_def;
END;
$BODY$;



ALTER FUNCTION ums.select_table_definition(text)
    OWNER TO postgres;

   CREATE OR REPLACE FUNCTION ums.select_table_user()
RETURNS json
LANGUAGE plpgsql
AS $BODY$
BEGIN
    RETURN (
        SELECT COALESCE(
            json_agg(
                json_build_object(
                    'id', tu.id,
                    'table_name', tu.tablename,
                    'user_id', tu.user_id,
                    'table_definition', ums.select_table_definition(tu.tablename)
                )
            ),
            '[]'::json
        )
        FROM ums.ums_table_user tu
    );
END;
$BODY$;

ALTER FUNCTION ums.select_table_user()
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.insert_table_user(
	IN id integer,
	IN user_id integer,
	IN tablename character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        INSERT INTO ums.ums_table_user (id, user_id, tablename)
        VALUES (id, user_id, tablename);
    END;
    
$BODY$;
ALTER PROCEDURE ums.insert_table_user(integer, integer, character varying)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.update_table_user(
	IN p_id integer,
	IN p_user_id integer,
	IN p_tablename character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_table_user
        SET id = p_id, user_id = p_user_id, tablename = p_tablename
        WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_table_user(integer, integer, character varying)
    OWNER TO postgres;


CREATE OR REPLACE PROCEDURE ums.delete_table_user(
	IN p_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        delete from ums.ums_table_user WHERE id = p_id;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_table_user(integer)
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION ums.select_trigger_user()
RETURNS json
LANGUAGE plpgsql
COST 100
VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT COALESCE(
            json_agg(
                json_build_object(
                    'id', tu.id,
                    'trigger_name', tu.trigger_name,
                    'user_id', tu.user_id,
                    'trigger_definition', (
                        SELECT pg_get_triggerdef(t.oid)
                        FROM pg_trigger t
                        JOIN pg_class c ON t.tgrelid = c.oid
                        JOIN pg_namespace n ON c.relnamespace = n.oid
                        WHERE t.tgname = tu.trigger_name
                        LIMIT 1
                    )
                )
            ), '[]'::json
        )
        FROM ums.ums_trigger_user tu
    );
END;
$BODY$;

ALTER FUNCTION ums.select_trigger_user()
    OWNER TO postgres;

CREATE OR REPLACE PROCEDURE ums.delete_trigger_user(
	IN p_id integer,
	IN p_trigger_name character varying
)
LANGUAGE plpgsql
AS $BODY$
DECLARE
    v_schema text := 'public';
    v_trigger_name text;
    v_table_name text;
    v_full_trigger_name text;
BEGIN
    -- Если имя триггера содержит схему (например: schema.trigger), извлекаем схему и имя триггера
    IF position('.' in p_trigger_name) > 0 THEN
        v_schema := split_part(p_trigger_name, '.', 1);
        v_trigger_name := split_part(p_trigger_name, '.', 2);
    ELSE
        v_trigger_name := p_trigger_name;
    END IF;

    -- Получаем имя таблицы, к которой привязан триггер
    SELECT event_object_table INTO v_table_name
    FROM information_schema.triggers
    WHERE trigger_schema = v_schema AND trigger_name = v_trigger_name
    LIMIT 1;

    -- Если таблица найдена, удаляем триггер
    IF v_table_name IS NOT NULL THEN
        EXECUTE format('DROP TRIGGER IF EXISTS %I ON %I.%I CASCADE', v_trigger_name, v_schema, v_table_name);
    END IF;

    -- Удаляем запись из таблицы
    DELETE FROM ums.ums_trigger_user WHERE id = p_id;
END;
$BODY$;

CREATE OR REPLACE FUNCTION ums.insert_role(rolename text)
RETURNS json AS
$$
DECLARE
    new_id integer;
BEGIN
    INSERT INTO ums.ums_roles (role_name)
    VALUES (rolename)
    RETURNING id INTO new_id;

    RETURN json_build_object('id', new_id);
END;
$$ LANGUAGE plpgsql;

    CREATE OR REPLACE FUNCTION ums.select_users(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
    BEGIN
        RETURN (SELECT json_agg(row_to_json(t)) FROM (SELECT id as id, username as username, password_hash as passwordhash FROM ums.ums_users) t);
    END;
    
$BODY$;

ALTER FUNCTION ums.select_users()
    OWNER TO postgres;


CREATE OR REPLACE PROCEDURE ums.delete_users(
	IN p_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        delete from ums.ums_users WHERE id = p_id;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_users(integer)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.update_user_auth_tokens(
	IN p_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    UPDATE ums.ums_user_auth_tokens
    SET is_revoked = TRUE,
        revoked_at = NOW()
    WHERE user_id = p_id;
END;
$BODY$;
ALTER PROCEDURE ums.update_user_auth_tokens(integer)
    OWNER TO postgres;


    CREATE OR REPLACE FUNCTION ums.select_userrole(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
    BEGIN
        RETURN (SELECT json_agg(row_to_json(t)) FROM (SELECT id as userroleid, user_id as userid, role_id as roleid FROM ums.ums_user_role) t);
    END;
    
$BODY$;

ALTER FUNCTION ums.select_userrole()
    OWNER TO postgres;


CREATE OR REPLACE PROCEDURE ums.insert_user_role(
	IN userid integer,
	IN roleid integer)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    INSERT INTO ums.ums_user_role (user_id, role_id)
    VALUES (userid, roleid);
END;
$BODY$;
ALTER PROCEDURE ums.insert_user_role(integer, integer)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.delete_user_role_by_user_id(
	IN p_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
         DELETE from ums.ums_user_role where user_id=p_id;
    END;
$BODY$;
ALTER PROCEDURE ums.delete_user_role_by_user_id(integer)
    OWNER TO postgres;


CREATE OR REPLACE FUNCTION ums.select_permissions()
RETURNS json
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN COALESCE(
        (SELECT json_agg(row_to_json(t)) 
         FROM (
             SELECT id AS permissionid, 
                    role_id AS roleid, 
                    table_name AS tablename, 
                    operation 
             FROM ums.ums_permissions
         ) t),
        '[]'::json
    );
END;
$$;


ALTER FUNCTION ums.select_permissions()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.insert_permissions(
	IN roleid integer,
	IN operation integer,
	IN tablename text)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        INSERT INTO ums.ums_permissions ( role_id, operation, table_name)
        VALUES ( roleid, operation, tablename);
    END;
    
$BODY$;
ALTER PROCEDURE ums.insert_permissions(integer, integer, text)
    OWNER TO postgres;


CREATE OR REPLACE PROCEDURE ums.delete_permissions(
	IN p_roleid integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
       DELETE FROM ums.ums_permissions WHERE role_id = p_roleid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_permissions(integer)
    OWNER TO postgres;


CREATE OR REPLACE FUNCTION ums.fn_apply_global_permission()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
    _role_name TEXT;
BEGIN
    -- fetch role name
    SELECT role_name INTO _role_name
    FROM ums.ums_roles
    WHERE id = COALESCE(NEW.role_id, OLD.role_id);

    -- helper to issue GRANT/REVOKE
    IF TG_OP = 'INSERT' THEN
        -- USAGE on schema
        IF NEW.grant_usage_schema THEN
            EXECUTE format('GRANT USAGE ON SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;

        -- CREATE on schema
        IF NEW.grant_create_obj THEN
            EXECUTE format('GRANT CREATE ON SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;

        -- CREATE on database
        IF NEW.grant_create_db THEN
            EXECUTE format('GRANT CREATE ON DATABASE %I TO %I',
                           current_database(), _role_name);
        END IF;

        -- GRANT on tables
        IF NEW.grant_select_tbl THEN
            EXECUTE format('GRANT SELECT ON ALL TABLES IN SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;
        IF NEW.grant_insert_tbl THEN
            EXECUTE format('GRANT INSERT ON ALL TABLES IN SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;
        IF NEW.grant_update_tbl THEN
            EXECUTE format('GRANT UPDATE ON ALL TABLES IN SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;
        IF NEW.grant_delete_tbl THEN
            EXECUTE format('GRANT DELETE ON ALL TABLES IN SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;
        IF NEW.grant_truncate_tbl THEN
            EXECUTE format('GRANT TRUNCATE ON ALL TABLES IN SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;
        IF NEW.grant_references_tbl THEN
            EXECUTE format('GRANT REFERENCES ON ALL TABLES IN SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;
        IF NEW.grant_trigger_tbl THEN
            EXECUTE format('GRANT TRIGGER ON ALL TABLES IN SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;

        -- GRANT on sequences
        IF NEW.grant_usage_seq THEN
            EXECUTE format('GRANT USAGE ON ALL SEQUENCES IN SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;
        IF NEW.grant_select_seq THEN
            EXECUTE format('GRANT SELECT ON ALL SEQUENCES IN SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;
        IF NEW.grant_update_seq THEN
            EXECUTE format('GRANT UPDATE ON ALL SEQUENCES IN SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;

        -- GRANT on functions
        IF NEW.grant_execute_func THEN
            EXECUTE format('GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA %I TO %I',
                           NEW.schema_name, _role_name);
        END IF;

    ELSIF TG_OP = 'DELETE' THEN
        -- REVOKE on tables
        IF OLD.grant_select_tbl THEN
            EXECUTE format('REVOKE SELECT ON ALL TABLES IN SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;
        IF OLD.grant_insert_tbl THEN
            EXECUTE format('REVOKE INSERT ON ALL TABLES IN SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;
        IF OLD.grant_update_tbl THEN
            EXECUTE format('REVOKE UPDATE ON ALL TABLES IN SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;
        IF OLD.grant_delete_tbl THEN
            EXECUTE format('REVOKE DELETE ON ALL TABLES IN SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;
        IF OLD.grant_truncate_tbl THEN
            EXECUTE format('REVOKE TRUNCATE ON ALL TABLES IN SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;
        IF OLD.grant_references_tbl THEN
            EXECUTE format('REVOKE REFERENCES ON ALL TABLES IN SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;
        IF OLD.grant_trigger_tbl THEN
            EXECUTE format('REVOKE TRIGGER ON ALL TABLES IN SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;

        -- REVOKE on sequences
        IF OLD.grant_usage_seq THEN
            EXECUTE format('REVOKE USAGE ON ALL SEQUENCES IN SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;
        IF OLD.grant_select_seq THEN
            EXECUTE format('REVOKE SELECT ON ALL SEQUENCES IN SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;
        IF OLD.grant_update_seq THEN
            EXECUTE format('REVOKE UPDATE ON ALL SEQUENCES IN SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;

        -- REVOKE on functions
        IF OLD.grant_execute_func THEN
            EXECUTE format('REVOKE EXECUTE ON ALL FUNCTIONS IN SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;

        -- REVOKE on schema
        IF OLD.grant_usage_schema THEN
            EXECUTE format('REVOKE USAGE ON SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;

        -- REVOKE CREATE on schema
        IF OLD.grant_create_obj THEN
            EXECUTE format('REVOKE CREATE ON SCHEMA %I FROM %I',
                           OLD.schema_name, _role_name);
        END IF;

        -- REVOKE CREATE on database
        IF OLD.grant_create_db THEN
            EXECUTE format('REVOKE CREATE ON DATABASE %I FROM %I',
                           current_database(), _role_name);
        END IF;
    END IF;

    RETURN COALESCE(NEW, OLD);
END;
$$;

-- 3) Single trigger for all operations
DROP TRIGGER IF EXISTS trg_apply_global_permission
  ON ums.ums_globalpermissions;

CREATE TRIGGER trg_apply_global_permission
  AFTER INSERT OR UPDATE OR DELETE
  ON ums.ums_globalpermissions
  FOR EACH ROW
  EXECUTE FUNCTION ums.fn_apply_global_permission();
  

  CREATE OR REPLACE FUNCTION ums.get_schemas_json()
RETURNS json
LANGUAGE sql
STABLE
AS $$
  SELECT json_agg(json_build_object(
    'schemaname', schema_name,
    'fromdb', true
  ))
  FROM information_schema.schemata;
$$;

CREATE OR REPLACE PROCEDURE ums.drop_schema(p_schemaname TEXT)
LANGUAGE plpgsql
AS
$$
BEGIN
    -- Проверяем, существует ли схема с таким названием
    IF NOT EXISTS (SELECT 1 FROM pg_catalog.pg_namespace WHERE nspname = p_schemaname) THEN
        RAISE EXCEPTION 'Схема "%" не существует', p_schemaname;
    END IF;

    -- Удаляем схему
    EXECUTE format('DROP SCHEMA IF EXISTS %I CASCADE', p_schemaname);
END;
$$;


CREATE OR REPLACE PROCEDURE ums.create_schema(p_schemaname TEXT)
LANGUAGE plpgsql
AS
$$
BEGIN
    -- Проверяем, существует ли схема с таким названием
    IF EXISTS (SELECT 1 FROM pg_catalog.pg_namespace WHERE nspname = p_schemaname) THEN
        RAISE EXCEPTION 'Схема "%" уже существует', p_schemaname;
    END IF;

    -- Создаём схему
    EXECUTE format('CREATE SCHEMA %I', p_schemaname);
END;
$$;
END;