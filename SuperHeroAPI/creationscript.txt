BEGIN;


CREATE TABLE IF NOT EXISTS ums.ums_user_auth_tokens
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    user_id integer NOT NULL,
    token text COLLATE pg_catalog."default" NOT NULL,
    expiration timestamp with time zone NOT NULL,
    is_revoked boolean NOT NULL DEFAULT false,
    revoked_at timestamp with time zone,
    CONSTRAINT user_auth_tokens_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_users
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    username text COLLATE pg_catalog."default" NOT NULL,
    password_hash text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ums_users_pkey PRIMARY KEY (id),
    CONSTRAINT ums_unique_username UNIQUE (username)
);

CREATE TABLE IF NOT EXISTS ums.ums_user_role
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    user_id integer NOT NULL,
    role_id integer NOT NULL,
    CONSTRAINT pk_user_role PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_roles
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    role_name text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ums_roles_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_globalpermissions
(
    permission_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    role_id integer NOT NULL,
    create_table_grant boolean NOT NULL DEFAULT false,
    update_table_grant boolean NOT NULL DEFAULT false,
    delete_table_grant boolean NOT NULL DEFAULT false,
    create_grant boolean NOT NULL DEFAULT false,
    CONSTRAINT pk_globalpermissions PRIMARY KEY (permission_id)
);

CREATE TABLE IF NOT EXISTS ums.ums_permissions
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    role_id integer NOT NULL,
    table_name text COLLATE pg_catalog."default" NOT NULL,
    operation integer NOT NULL,
    CONSTRAINT pk_permissions PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_function_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    function_name character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT function_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_procedure_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    procedure_name character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT procedure_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_table_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    tablename character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT table_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_trigger_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    trigger_name character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT trigger_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_request_logs
(
    id serial NOT NULL,
    user_id integer,
    path text COLLATE pg_catalog."default" NOT NULL,
    method character varying(10) COLLATE pg_catalog."default" NOT NULL,
    query_string text COLLATE pg_catalog."default" NOT NULL,
    request_body text COLLATE pg_catalog."default" NOT NULL,
    response_body text COLLATE pg_catalog."default" NOT NULL,
    status_code integer NOT NULL,
    request_time timestamp without time zone NOT NULL,
    response_time timestamp without time zone NOT NULL,
    duration interval NOT NULL,
    ip_address character varying(45) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ums_request_logs_pkey PRIMARY KEY (id)
);

-- Create the Containers table for managing Kubernetes deployments
CREATE TABLE IF NOT EXISTS ums.ums_containers
(
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL,
    db_host VARCHAR(255) NOT NULL,
    db_port VARCHAR(10) NOT NULL,
    db_name VARCHAR(255) NOT NULL,
    db_user VARCHAR(255) NOT NULL,
    db_password VARCHAR(255) NOT NULL,
    db_username VARCHAR(255) NOT NULL,
    db_password_user VARCHAR(255) NOT NULL,
    external_url VARCHAR(255) NOT NULL DEFAULT '',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Grant necessary permissions for the containers table
--INSERT INTO ums.ums_permissions (role_id, table_name, operation)
--SELECT id, 'ums.containers', 10 -- ALL PRIVILEGES
--FROM ums.ums_roles 
--WHERE role_name = 'superadmin'
--ON CONFLICT DO NOTHING;

ALTER TABLE IF EXISTS ums.ums_user_auth_tokens
    ADD CONSTRAINT fk_user_id FOREIGN KEY (id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;
CREATE INDEX IF NOT EXISTS user_auth_tokens_pkey
    ON ums.ums_user_auth_tokens(id);


ALTER TABLE IF EXISTS ums.ums_user_role
    ADD CONSTRAINT fk_user_role_roles_role_id FOREIGN KEY (role_id)
    REFERENCES ums.ums_roles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_UserRole_RoleId"
    ON ums.ums_user_role(role_id);


ALTER TABLE IF EXISTS ums.ums_user_role
    ADD CONSTRAINT fk_user_role_users_user_id FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_UserRole_UserId"
    ON ums.ums_user_role(user_id);


ALTER TABLE IF EXISTS ums.ums_globalpermissions
    ADD CONSTRAINT fk_role_id FOREIGN KEY (role_id)
    REFERENCES ums.ums_roles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS ums.ums_permissions
    ADD CONSTRAINT fk_role_id FOREIGN KEY (role_id)
    REFERENCES ums.ums_roles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS ums.ums_function_user
    ADD CONSTRAINT function_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_procedure_user
    ADD CONSTRAINT procedure_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_table_user
    ADD CONSTRAINT table_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_trigger_user
    ADD CONSTRAINT trigger_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_request_logs
    ADD CONSTRAINT fk_user FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_request_logs_user_id
    ON ums.ums_request_logs(user_id);

ALTER DATABASE superherodb SET search_path TO ums, public;

CREATE OR REPLACE FUNCTION ums.add_global_permission_to_role()
RETURNS trigger
LANGUAGE plpgsql
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    r RECORD;
BEGIN
    -- �������� ��� ���� �� ������ role_id
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = NEW.role_id;

    -- ���������� �� ���� ���������������� ������ (��� ���������)
    FOR r IN
        SELECT schema_name
        FROM information_schema.schemata
        WHERE schema_name NOT IN ('pg_catalog', 'information_schema')
    LOOP
        -- CREATE ON DATABASE (����� ������ 1 ���, �� �� ������)
        IF NEW.create_table_grant THEN
            EXECUTE format('GRANT CREATE ON DATABASE %I TO %I', 'superherodb', role_name);
        END IF;

        -- UPDATE ON ������� � ������ �����
        IF NEW.update_table_grant THEN
            EXECUTE format('GRANT UPDATE ON ALL TABLES IN SCHEMA %I TO %I', r.schema_name, role_name);
        END IF;

        -- DELETE ON ������� � ������ �����
        IF NEW.delete_table_grant THEN
            EXECUTE format('GRANT DELETE ON ALL TABLES IN SCHEMA %I TO %I', r.schema_name, role_name);
        END IF;

        -- CREATE ON �����
        IF NEW.create_grant THEN
            EXECUTE format('GRANT CREATE ON SCHEMA %I TO %I', r.schema_name, role_name);
        END IF;

        -- USAGE �� ����� � ������� ������, ����� ������ ����� ���� ������������ ���������
        EXECUTE format('GRANT USAGE ON SCHEMA %I TO %I', r.schema_name, role_name);
    END LOOP;

    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION ums.add_global_permission_to_role()
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION ums.add_permission_to_role()
RETURNS trigger
LANGUAGE 'plpgsql'
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    schema_name TEXT := 'public'; -- ����� �� ���������
    table_name TEXT;
    column_name TEXT;
    full_table_ref TEXT;
BEGIN
    -- �������� ��� ���� �� role_id
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = NEW.role_id;

    -- ���������, ���� �� ����� � ����� �������
    IF POSITION('.' IN NEW.table_name) > 0 THEN
        -- table_name �������� 'schema.table' ��� 'table.column'
        IF NEW.operation IN (0,1,2) AND POSITION('.' IN split_part(NEW.table_name, '.', 2)) > 0 THEN
            -- ������: table.column (��� �����)
            table_name := split_part(NEW.table_name, '.', 1);
            column_name := split_part(NEW.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        ELSE
            -- ������: schema.table
            schema_name := split_part(NEW.table_name, '.', 1);
            table_name := split_part(NEW.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        END IF;
    ELSE
        -- ������ ��� �������
        table_name := NEW.table_name;
        full_table_ref := format('%I.%I', schema_name, table_name);
    END IF;

    -- ��������� ����������
    IF NEW.operation = 0 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('GRANT INSERT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('GRANT INSERT ON TABLE %s TO %I', full_table_ref, role_name);
        END IF;
    ELSIF NEW.operation = 1 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('GRANT SELECT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('GRANT SELECT ON TABLE %s TO %I', full_table_ref, role_name);
        END IF;
    ELSIF NEW.operation = 2 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('GRANT UPDATE (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('GRANT UPDATE ON TABLE %s TO %I', full_table_ref, role_name);
        END IF;
    ELSIF NEW.operation = 3 THEN
        EXECUTE format('GRANT DELETE ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 4 THEN
        EXECUTE format('GRANT ALTER ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 5 THEN
        EXECUTE format('GRANT DROP ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 6 THEN
        EXECUTE format('GRANT TRIGGER ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 7 THEN
        EXECUTE format('GRANT CREATE ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 8 THEN
        EXECUTE format('GRANT VACUUM ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 9 THEN
        EXECUTE format('GRANT ANALYZE ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 10 THEN
        EXECUTE format('GRANT ALL PRIVILEGES ON TABLE %s TO %I', full_table_ref, role_name);
    END IF;

    RETURN NEW;
END;
$BODY$;



ALTER FUNCTION ums.add_permission_to_role()
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION ums.create_role_from_roles_table()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Check if the role_name is not null
    IF NEW.role_name IS NOT NULL THEN
        -- Create the role with the provided name
        EXECUTE format('CREATE ROLE %I', NEW.role_name);
    END IF;
    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION ums.create_role_from_roles_table()
    OWNER TO postgres;

-- FUNCTION: ums.delete_global_permission_from_role()
CREATE OR REPLACE FUNCTION ums.delete_global_permission_from_role()
RETURNS trigger
LANGUAGE plpgsql
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    r RECORD;
BEGIN
    -- �������� ��� ���� �� ������ role_id
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = OLD.role_id;

    -- ����� ���� ���������������� ���� (��� ���������)
    FOR r IN
        SELECT schema_name
        FROM information_schema.schemata
        WHERE schema_name NOT IN ('pg_catalog', 'information_schema')
    LOOP
        -- ����� CREATE ON DATABASE (���� ���)
        IF OLD.create_table_grant THEN
            EXECUTE format('REVOKE CREATE ON DATABASE %I FROM %I', 'superherodb', role_name);
        END IF;

        -- ����� ���� �� ������� �� ������ �����
        IF OLD.update_table_grant THEN
            EXECUTE format('REVOKE UPDATE ON ALL TABLES IN SCHEMA %I FROM %I', r.schema_name, role_name);
        END IF;

        IF OLD.delete_table_grant THEN
            EXECUTE format('REVOKE DELETE ON ALL TABLES IN SCHEMA %I FROM %I', r.schema_name, role_name);
        END IF;

        -- ����� CREATE �� �����
        IF OLD.create_grant THEN
            EXECUTE format('REVOKE CREATE ON SCHEMA %I FROM %I', r.schema_name, role_name);
        END IF;

        -- ����� �������� USAGE ���� ����� �������� (�����������)
        EXECUTE format('REVOKE USAGE ON SCHEMA %I FROM %I', r.schema_name, role_name);
    END LOOP;

    RETURN OLD;
END;
$BODY$;


ALTER FUNCTION ums.delete_global_permission_from_role()
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION ums.delete_permission_from_role()
RETURNS trigger
LANGUAGE plpgsql
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    schema_name TEXT := 'public'; -- ����� �� ���������
    table_name TEXT;
    column_name TEXT;
    full_table_ref TEXT;
BEGIN
    -- �������� ��� ���� �� role_id
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = OLD.role_id;

    -- ���������� ������: column-level ��� schema.table
    IF POSITION('.' IN OLD.table_name) > 0 THEN
        -- ���� ������ ����� �������� ��� ���� ����� � ������ ��� table.column
        IF OLD.operation IN (0,1,2) AND POSITION('.' IN split_part(OLD.table_name, '.', 2)) > 0 THEN
            -- column-level
            table_name := split_part(OLD.table_name, '.', 1);
            column_name := split_part(OLD.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        ELSE
            -- schema.table
            schema_name := split_part(OLD.table_name, '.', 1);
            table_name := split_part(OLD.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        END IF;
    ELSE
        -- ������ ��� �������, ��� �����
        table_name := OLD.table_name;
        full_table_ref := format('%I.%I', schema_name, table_name);
    END IF;

    -- ����� ����
    IF OLD.operation = 0 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('REVOKE INSERT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('REVOKE INSERT ON TABLE %s FROM %I', full_table_ref, role_name);
        END IF;
    ELSIF OLD.operation = 1 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('REVOKE SELECT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('REVOKE SELECT ON TABLE %s FROM %I', full_table_ref, role_name);
        END IF;
    ELSIF OLD.operation = 2 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('REVOKE UPDATE (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('REVOKE UPDATE ON TABLE %s FROM %I', full_table_ref, role_name);
        END IF;
    ELSIF OLD.operation = 3 THEN
        EXECUTE format('REVOKE DELETE ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 4 THEN
        EXECUTE format('REVOKE ALTER ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 5 THEN
        EXECUTE format('REVOKE DROP ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 6 THEN
        EXECUTE format('REVOKE TRIGGER ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 7 THEN
        EXECUTE format('REVOKE CREATE ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 8 THEN
        EXECUTE format('REVOKE VACUUM ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 9 THEN
        EXECUTE format('REVOKE ANALYZE ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 10 THEN
        EXECUTE format('REVOKE ALL PRIVILEGES ON TABLE %s FROM %I', full_table_ref, role_name);
    END IF;

    RETURN OLD;
END;
$BODY$;


ALTER FUNCTION ums.delete_permission_from_role()
    OWNER TO postgres;

-- FUNCTION: ums.delete_role_from_roles_table()
CREATE OR REPLACE FUNCTION ums.delete_role_from_roles_table()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Drop the role if it exists
    EXECUTE format('DROP ROLE IF EXISTS %I', OLD.role_name);
    RETURN OLD;
END;
$BODY$;

ALTER FUNCTION ums.delete_role_from_roles_table()
    OWNER TO postgres;

-- FUNCTION: ums.update_global_role_permissions()
CREATE OR REPLACE FUNCTION ums.update_global_role_permissions()
RETURNS trigger
LANGUAGE plpgsql
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    r RECORD;
BEGIN
    -- �������� ��� ���� �� role_id
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = NEW.role_id;

    -- CREATE ON DATABASE (������ ���� ���, �� ������� �� ����)
    IF OLD.create_table_grant <> NEW.create_table_grant THEN
        IF OLD.create_table_grant THEN
            EXECUTE format('REVOKE CREATE ON DATABASE %I FROM %I', 'superherodb', role_name);
        END IF;
        IF NEW.create_table_grant THEN
            EXECUTE format('GRANT CREATE ON DATABASE %I TO %I', 'superherodb', role_name);
        END IF;
    END IF;

    -- ����� ���� ���������������� ����
    FOR r IN
        SELECT schema_name
        FROM information_schema.schemata
        WHERE schema_name NOT IN ('pg_catalog', 'information_schema')
    LOOP
        -- UPDATE ON TABLES
        IF OLD.update_table_grant <> NEW.update_table_grant THEN
            IF OLD.update_table_grant THEN
                EXECUTE format('REVOKE UPDATE ON ALL TABLES IN SCHEMA %I FROM %I', r.schema_name, role_name);
            END IF;
            IF NEW.update_table_grant THEN
                EXECUTE format('GRANT UPDATE ON ALL TABLES IN SCHEMA %I TO %I', r.schema_name, role_name);
            END IF;
        END IF;

        -- DELETE ON TABLES
        IF OLD.delete_table_grant <> NEW.delete_table_grant THEN
            IF OLD.delete_table_grant THEN
                EXECUTE format('REVOKE DELETE ON ALL TABLES IN SCHEMA %I FROM %I', r.schema_name, role_name);
            END IF;
            IF NEW.delete_table_grant THEN
                EXECUTE format('GRANT DELETE ON ALL TABLES IN SCHEMA %I TO %I', r.schema_name, role_name);
            END IF;
        END IF;

        -- CREATE ON SCHEMA
        IF OLD.create_grant <> NEW.create_grant THEN
            IF OLD.create_grant THEN
                EXECUTE format('REVOKE CREATE ON SCHEMA %I FROM %I', r.schema_name, role_name);
            END IF;
            IF NEW.create_grant THEN
                EXECUTE format('GRANT CREATE ON SCHEMA %I TO %I', r.schema_name, role_name);
            END IF;
        END IF;

        -- ������� USAGE ����� ��������� �� ������� (����� �� �������, �� ����� ��������)
    END LOOP;

    RETURN NEW;
END;
$BODY$;


ALTER FUNCTION ums.update_global_role_permissions()
    OWNER TO postgres;

-- FUNCTION: ums.update_role_from_roles_table()
CREATE OR REPLACE FUNCTION ums.update_role_from_roles_table()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Check if the role_name has been modified
    IF OLD.role_name <> NEW.role_name THEN
        -- Check if the old role exists
        PERFORM 1 FROM pg_roles WHERE rolname = OLD.role_name;
        IF FOUND THEN
            -- Rename the old role to the new role
            EXECUTE format('ALTER ROLE %I RENAME TO %I', OLD.role_name, NEW.role_name);
        END IF;
    END IF;
    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION ums.update_role_from_roles_table()
    OWNER TO postgres;

-- FUNCTION: ums.update_role_permissions()
CREATE OR REPLACE FUNCTION ums.update_role_permissions()
RETURNS trigger
LANGUAGE plpgsql
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    schema_name TEXT := 'public'; -- �� ���������
    table_name TEXT;
    column_name TEXT;
    full_table_ref TEXT;
BEGIN
    -- �������� ��� ����
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = NEW.role_id;

    -- ������ ���� operation ��� table_name ����������
    IF OLD.operation <> NEW.operation OR OLD.table_name <> NEW.table_name THEN

        ---------------------------------------------------------------------
        -- 1. REVOKE ������ �����
        ---------------------------------------------------------------------
        -- ���������� �����, ������� � ������� �� OLD.table_name
        column_name := NULL;
        IF POSITION('.' IN OLD.table_name) > 0 THEN
            IF OLD.operation IN (0,1,2) AND POSITION('.' IN split_part(OLD.table_name, '.', 2)) > 0 THEN
                -- table.column
                table_name := split_part(OLD.table_name, '.', 1);
                column_name := split_part(OLD.table_name, '.', 2);
            ELSE
                -- schema.table
                schema_name := split_part(OLD.table_name, '.', 1);
                table_name := split_part(OLD.table_name, '.', 2);
            END IF;
        ELSE
            table_name := OLD.table_name;
        END IF;
        full_table_ref := format('%I.%I', schema_name, table_name);

        IF OLD.operation = 0 AND column_name IS NOT NULL THEN
            EXECUTE format('REVOKE INSERT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSIF OLD.operation = 1 AND column_name IS NOT NULL THEN
            EXECUTE format('REVOKE SELECT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSIF OLD.operation = 2 AND column_name IS NOT NULL THEN
            EXECUTE format('REVOKE UPDATE (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            CASE OLD.operation
                WHEN 0 THEN EXECUTE format('REVOKE INSERT ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 1 THEN EXECUTE format('REVOKE SELECT ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 2 THEN EXECUTE format('REVOKE UPDATE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 3 THEN EXECUTE format('REVOKE DELETE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 4 THEN EXECUTE format('REVOKE ALTER ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 5 THEN EXECUTE format('REVOKE DROP ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 6 THEN EXECUTE format('REVOKE TRIGGER ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 7 THEN EXECUTE format('REVOKE CREATE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 8 THEN EXECUTE format('REVOKE VACUUM ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 9 THEN EXECUTE format('REVOKE ANALYZE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 10 THEN EXECUTE format('REVOKE ALL PRIVILEGES ON TABLE %s FROM %I', full_table_ref, role_name);
            END CASE;
        END IF;

        ---------------------------------------------------------------------
        -- 2. GRANT ����� �����
        ---------------------------------------------------------------------
        schema_name := 'public'; -- ���������� ����� �� ���������
        column_name := NULL;

        IF POSITION('.' IN NEW.table_name) > 0 THEN
            IF NEW.operation IN (0,1,2) AND POSITION('.' IN split_part(NEW.table_name, '.', 2)) > 0 THEN
                -- table.column
                table_name := split_part(NEW.table_name, '.', 1);
                column_name := split_part(NEW.table_name, '.', 2);
            ELSE
                -- schema.table
                schema_name := split_part(NEW.table_name, '.', 1);
                table_name := split_part(NEW.table_name, '.', 2);
            END IF;
        ELSE
            table_name := NEW.table_name;
        END IF;
        full_table_ref := format('%I.%I', schema_name, table_name);

        IF NEW.operation = 0 AND column_name IS NOT NULL THEN
            EXECUTE format('GRANT INSERT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSIF NEW.operation = 1 AND column_name IS NOT NULL THEN
            EXECUTE format('GRANT SELECT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSIF NEW.operation = 2 AND column_name IS NOT NULL THEN
            EXECUTE format('GRANT UPDATE (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            CASE NEW.operation
                WHEN 0 THEN EXECUTE format('GRANT INSERT ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 1 THEN EXECUTE format('GRANT SELECT ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 2 THEN EXECUTE format('GRANT UPDATE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 3 THEN EXECUTE format('GRANT DELETE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 4 THEN EXECUTE format('GRANT ALTER ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 5 THEN EXECUTE format('GRANT DROP ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 6 THEN EXECUTE format('GRANT TRIGGER ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 7 THEN EXECUTE format('GRANT CREATE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 8 THEN EXECUTE format('GRANT VACUUM ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 9 THEN EXECUTE format('GRANT ANALYZE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 10 THEN EXECUTE format('GRANT ALL PRIVILEGES ON TABLE %s TO %I', full_table_ref, role_name);
            END CASE;
        END IF;
    END IF;

    RETURN NEW;
END;
$BODY$;


ALTER FUNCTION ums.update_role_permissions()
    OWNER TO postgres;

-- Создание или обновление триггеров для таблиц
CREATE OR REPLACE TRIGGER tr_create_role_from_roles_table
    AFTER INSERT
    ON ums.ums_roles
    FOR EACH ROW
    EXECUTE FUNCTION ums.create_role_from_roles_table();

CREATE OR REPLACE TRIGGER tr_update_role_from_roles_table
    AFTER UPDATE
    ON ums.ums_roles
    FOR EACH ROW
    EXECUTE FUNCTION ums.update_role_from_roles_table();

CREATE OR REPLACE TRIGGER tr_delete_role_from_roles_table
    BEFORE DELETE
    ON ums.ums_roles
    FOR EACH ROW
    EXECUTE FUNCTION ums.delete_role_from_roles_table();

CREATE OR REPLACE TRIGGER tr_add_permission_to_role
    AFTER INSERT
    ON ums.ums_permissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.add_permission_to_role();

CREATE OR REPLACE TRIGGER tr_update_role_permissions
    AFTER UPDATE
    ON ums.ums_permissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.update_role_permissions();

CREATE OR REPLACE TRIGGER tr_delete_permission_from_role
    BEFORE DELETE
    ON ums.ums_permissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.delete_permission_from_role();

CREATE OR REPLACE TRIGGER tr_add_global_permission_to_role
    AFTER INSERT
    ON ums.ums_globalpermissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.add_global_permission_to_role();

CREATE OR REPLACE TRIGGER tr_update_global_role_permissions
    AFTER UPDATE
    ON ums.ums_globalpermissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.update_global_role_permissions();

CREATE OR REPLACE TRIGGER tr_delete_global_permission_from_role
    BEFORE DELETE
    ON ums.ums_globalpermissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.delete_global_permission_from_role(); 

    CREATE OR REPLACE FUNCTION ums.select_roles(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT json_agg(row_to_json(t)) 
        FROM (
            SELECT
                id as roleid,
                role_name as rolename
            FROM ums.ums_roles
        ) t
    );
END;
$BODY$;

ALTER FUNCTION ums.select_roles()
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.update_roles(
	IN p_roleid integer,
	IN p_rolename text)
LANGUAGE 'plpgsql'
AS $BODY$

    BEGIN
        UPDATE ums.ums_roles
        SET  role_name = p_rolename
        WHERE id = p_roleid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_roles(integer, text)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.delete_roles(
	IN p_roleid integer)
LANGUAGE 'plpgsql'
AS $BODY$

    BEGIN
	DELETE from globalpermissions where roleid=p_roleid;
        DELETE from ums.ums_roles WHERE id = p_roleid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_roles(integer)
    OWNER TO postgres;

    CREATE OR REPLACE FUNCTION ums.select_globalpermissions(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
    BEGIN
        RETURN (SELECT json_agg(row_to_json(t)) FROM (SELECT * FROM ums.ums_globalpermissions) t);
    END;
    
$BODY$;

ALTER FUNCTION ums.select_globalpermissions()
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.insert_globalpermissions(
	IN roleid integer,
	IN create_table_grant boolean,
	IN update_table_grant boolean,
	IN delete_table_grant boolean,
	IN create_grant boolean)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        INSERT INTO ums.ums_globalpermissions (roleid, create_table_grant, update_table_grant, delete_table_grant, create_grant)
        VALUES (roleid, create_table_grant, update_table_grant, delete_table_grant, create_grant);
    END;
    
$BODY$;
ALTER PROCEDURE ums.insert_globalpermissions(integer, boolean, boolean, boolean, boolean)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.update_globalpermissions(
	IN p_permissionid integer,
	IN p_roleid integer,
	IN p_create_table_grant boolean,
	IN p_update_table_grant boolean,
	IN p_delete_table_grant boolean,
	IN p_create_grant boolean)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    -- ���������, ���������� �� ������ � ����� permissionid
    IF EXISTS (SELECT 1 FROM ums.ums_globalpermissions WHERE permissionid = p_permissionid) THEN
        -- ���� ������ ����������, ��������� �
        UPDATE ums.ums_globalpermissions
        SET roleid = p_roleid,
            create_table_grant = p_create_table_grant,
            update_table_grant = p_update_table_grant,
            delete_table_grant = p_delete_table_grant,
            create_grant = p_create_grant
        WHERE permissionid = p_permissionid;
    ELSE
        -- ���� ������ ���, ��������� �����, �� �� ��������� p_permissionid, ���� ��� SERIAL
        INSERT INTO ums.ums_globalpermissions (roleid, create_table_grant, update_table_grant, delete_table_grant, create_grant)
        VALUES (p_roleid, p_create_table_grant, p_update_table_grant, p_delete_table_grant, p_create_grant);
    END IF;
END;
    
$BODY$;
ALTER PROCEDURE ums.update_globalpermissions(integer, integer, boolean, boolean, boolean, boolean)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.delete_globalpermissions(
	IN p_roleid integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        delete from ums.ums_globalpermissions WHERE roleid  = p_roleid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_globalpermissions(integer)
    OWNER TO postgres;


    CREATE OR REPLACE FUNCTION ums.select_function_user(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT json_agg(
            json_build_object(
                'id', fu.id,
                'functionname', fu.function_name,
                'userid', fu.user_id,
                'functiondefinition', pg_get_functiondef(p.oid)
            )
        )
        FROM ums.ums_function_user fu
        JOIN pg_proc p ON p.proname = fu.function_name
        JOIN pg_namespace n ON p.pronamespace = n.oid
       
    );
END;
$BODY$;

ALTER FUNCTION ums.select_function_user()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.update_function_user(
	IN p_id integer,
	IN p_user_id integer,
	IN p_function_name character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_function_user
        SET id = p_id, user_id = p_user_id, function_name = p_function_name
        WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_function_user(integer, integer, character varying)
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.delete_function_user(
	IN p_id integer,
	IN p_functionname character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
		DROP function if exists p_functionname;
        DELETE from ums.ums_function_user where id=p_id;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_function_user(integer, character varying)
    OWNER TO postgres;

    CREATE OR REPLACE FUNCTION ums.select_procedure_user(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT json_agg(
            json_build_object(
                'id', fu.id,
                'procedure_name', fu.procedure_name,
                'user_id', fu.user_id,
                'procedure_definition', pg_get_functiondef(p.oid)
            )
        )
        FROM ums.ums_procedure_user fu
        JOIN pg_proc p ON p.proname = fu.procedure_name
        JOIN pg_namespace n ON p.pronamespace = n.oid
    );
END;
$BODY$;

ALTER FUNCTION ums.select_procedure_user()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.update_procedure_user(
	IN p_id integer,
	IN p_user_id integer,
	IN p_procedure_name character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_procedure_user
        SET id = p_id, user_id = p_user_id, procedure_name = p_procedure_name
        WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_procedure_user(integer, integer, character varying)
    OWNER TO postgres;

CREATE OR REPLACE PROCEDURE ums.delete_procedure_user(
    IN p_id integer,
    IN p_procedurename character varying
)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_schema text := 'public';
    v_procname text;
    v_full_name text;
BEGIN
    -- ��������� ���, ���� ������� �����
    IF position('.' in p_procedurename) > 0 THEN
        v_schema := split_part(p_procedurename, '.', 1);
        v_procname := split_part(p_procedurename, '.', 2);
    ELSE
        v_procname := p_procedurename;
    END IF;

    -- ���������� ������ ��� ��������� ��� ��������
    v_full_name := format('%I.%I', v_schema, v_procname);

    -- ������� ��������� (��������������, ��� � �� ��� ���������� ��� ��������� �����������)
    EXECUTE format('DROP PROCEDURE IF EXISTS %s', v_full_name);

    -- ������� ������ �� �������
    DELETE FROM procedure_user WHERE id = p_id;
END;
$BODY$;

ALTER PROCEDURE ums.delete_procedure_user(integer, character varying)
    OWNER TO postgres;


    
    CREATE OR REPLACE FUNCTION ums.select_table_definition(
	table_name text)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    table_def text;
    column_def text;
    constraint_def text;
    row record;
BEGIN
    -- Start building the CREATE TABLE statement
    table_def := 'CREATE TABLE ' || table_name || ' (' || chr(10);

    -- Fetch column definitions
    FOR row IN
        SELECT
            a.attname AS column_name,
            pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type,
            CASE WHEN a.attnotnull THEN 'NOT NULL' ELSE '' END AS not_null
        FROM
            pg_attribute a
        JOIN pg_class c ON a.attrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE
            c.relname = table_name
            AND a.attnum > 0
            AND NOT a.attisdropped
        ORDER BY a.attnum
    LOOP
        column_def := '    ' || row.column_name || ' ' || row.data_type || ' ' || row.not_null || ',' || chr(10);
        table_def := table_def || column_def;
    END LOOP;

    -- Fetch constraint definitions (PRIMARY KEY, UNIQUE, etc.)
    FOR row IN
        SELECT
            conname AS constraint_name,
            pg_get_constraintdef(c.oid) AS constraint_def
        FROM
            pg_constraint c
        JOIN pg_class rel ON c.conrelid = rel.oid
        JOIN pg_namespace n ON rel.relnamespace = n.oid
        WHERE
            rel.relname = table_name
    LOOP
        constraint_def := '    ' || 'CONSTRAINT ' || row.constraint_name || ' ' || row.constraint_def || ',' || chr(10);
        table_def := table_def || constraint_def;
    END LOOP;

    -- Remove the last comma and add closing parenthesis
    table_def := rtrim(table_def, ',' || chr(10)) || chr(10) || ');';

    -- Return the full table definition
    RETURN table_def;
END;
$BODY$;

ALTER FUNCTION ums.select_table_definition(text)
    OWNER TO postgres;

    CREATE OR REPLACE FUNCTION ums.select_table_user(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT json_agg(
            json_build_object(
                'id', tu.id,
                'table_name', tu.tablename,
                'user_id', tu.user_id,
                'table_definition', ums.select_table_definition(tu.tablename)
            )
        )
        FROM ums.ums_table_user tu
    );
END;
$BODY$;

ALTER FUNCTION ums.select_table_user()
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.insert_table_user(
	IN id integer,
	IN user_id integer,
	IN tablename character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        INSERT INTO ums.ums_table_user (id, user_id, tablename)
        VALUES (id, user_id, tablename);
    END;
    
$BODY$;
ALTER PROCEDURE ums.insert_table_user(integer, integer, character varying)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.update_table_user(
	IN p_id integer,
	IN p_user_id integer,
	IN p_tablename character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_table_user
        SET id = p_id, user_id = p_user_id, tablename = p_tablename
        WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_table_user(integer, integer, character varying)
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.delete_table_user(
	IN p_oid integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_table_user SET deleted_at = now() WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_table_user(integer)
    OWNER TO postgres;

    CREATE OR REPLACE FUNCTION ums.select_trigger_user(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT json_agg(
            json_build_object(
                'id', tu.id,
                'trigger_name', tu.trigger_name,
                'user_id', tu.user_id,
                'trigger_definition', (
                    SELECT pg_get_triggerdef(t.oid)
                    FROM pg_trigger t
                    JOIN pg_class c ON t.tgrelid = c.oid
                    JOIN pg_namespace n ON c.relnamespace = n.oid
                    WHERE t.tgname = tu.trigger_name
                )
            )
        )
        FROM ums.ums_trigger_user tu
    );
END;
$BODY$;

ALTER FUNCTION ums.select_trigger_user()
    OWNER TO postgres;


    CREATE OR REPLACE FUNCTION ums.select_users(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
    BEGIN
        RETURN (SELECT json_agg(row_to_json(t)) FROM (SELECT id as id, username as username, password_hash as passwordhash FROM ums.ums_users) t);
    END;
    
$BODY$;

ALTER FUNCTION ums.select_users()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.delete_users(
	IN p_oid integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_users SET deleted_at = now() WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_users(integer)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.update_user_auth_tokens(
	IN p_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    UPDATE ums.ums_user_auth_tokens
    SET is_revoked = TRUE,
        revoked_at = NOW()
    WHERE user_id = p_id;
END;
$BODY$;
ALTER PROCEDURE ums.update_user_auth_tokens(integer)
    OWNER TO postgres;


    CREATE OR REPLACE FUNCTION ums.select_userrole(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
    BEGIN
        RETURN (SELECT json_agg(row_to_json(t)) FROM (SELECT id as userroleid, user_id as userid, role_id as roleid FROM ums.ums_user_role) t);
    END;
    
$BODY$;

ALTER FUNCTION ums.select_userrole()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.insert_user_role(
	IN user_id integer,
	IN role_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    INSERT INTO ums.ums_user_role (user_id, role_id)
    VALUES (user_id, role_id);
END;
$BODY$;
ALTER PROCEDURE ums.insert_user_role(integer, integer)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.delete_user_role_by_user_id(
	IN p_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
         DELETE from ums.ums_user_role where user_id=p_id;
    END;
$BODY$;
ALTER PROCEDURE ums.delete_user_role_by_user_id(integer)
    OWNER TO postgres;


    CREATE OR REPLACE FUNCTION ums.select_permissions(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
    BEGIN
        RETURN (SELECT json_agg(row_to_json(t)) FROM (SELECT id as permissionid, role_id as roleid, table_name as tablename, operation as operation  FROM ums.ums_permissions) t);
    END;
    
$BODY$;

ALTER FUNCTION ums.select_permissions()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.insert_permissions(
	IN roleid integer,
	IN operation integer,
	IN tablename text)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        INSERT INTO ums.ums_permissions ( role_id, operation, table_name)
        VALUES ( roleid, operation, tablename);
    END;
    
$BODY$;
ALTER PROCEDURE ums.insert_permissions(integer, integer, text)
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.delete_permissions(
	IN p_permissionid integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
       DELETE FROM ums.ums_permissions WHERE id = p_permissionid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_permissions(integer)
    OWNER TO postgres;

END;