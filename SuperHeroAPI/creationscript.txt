BEGIN;

ALTER DATABASE superherodb SET search_path TO public, ums;




CREATE TABLE IF NOT EXISTS ums.ums_user_auth_tokens
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    user_id integer NOT NULL,
    token text COLLATE pg_catalog."default" NOT NULL,
    expiration timestamp with time zone NOT NULL,
    is_revoked boolean NOT NULL DEFAULT false,
    revoked_at timestamp with time zone,
    CONSTRAINT user_auth_tokens_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_users
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    username text COLLATE pg_catalog."default" NOT NULL,
    password_hash text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ums_users_pkey PRIMARY KEY (id),
    CONSTRAINT ums_unique_username UNIQUE (username)
);

CREATE TABLE IF NOT EXISTS ums.ums_user_role
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    user_id integer NOT NULL,
    role_id integer NOT NULL,
    CONSTRAINT pk_user_role PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_roles
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    role_name text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ums_roles_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_globalpermissions
(
    permission_id      SERIAL PRIMARY KEY,
    role_id            INTEGER,
    schema_name        text    NOT NULL,
    grant_create_db    BOOLEAN NOT NULL DEFAULT FALSE,  -- CREATE new schemas
    grant_create_obj   BOOLEAN NOT NULL DEFAULT FALSE,  -- CREATE objects in schema
    grant_update_tbl   BOOLEAN NOT NULL DEFAULT FALSE,
    grant_delete_tbl   BOOLEAN NOT NULL DEFAULT FALSE,
    CONSTRAINT uq_role_schema UNIQUE (role_id, schema_name)
);

CREATE TABLE IF NOT EXISTS ums.ums_permissions
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    role_id integer NOT NULL,
    table_name text COLLATE pg_catalog."default" NOT NULL,
    operation integer NOT NULL,
    CONSTRAINT pk_permissions PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_function_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    function_name character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT function_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_procedure_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    procedure_name character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT procedure_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_table_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    tablename character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT table_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_trigger_user
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    trigger_name character varying COLLATE pg_catalog."default",
    user_id integer,
    CONSTRAINT trigger_user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ums.ums_request_logs
(
    id serial NOT NULL,
    user_id integer,
    path text COLLATE pg_catalog."default" NOT NULL,
    method character varying(10) COLLATE pg_catalog."default" NOT NULL,
    query_string text COLLATE pg_catalog."default" NOT NULL,
    request_body text COLLATE pg_catalog."default" NOT NULL,
    response_body text COLLATE pg_catalog."default" NOT NULL,
    status_code integer NOT NULL,
    request_time timestamp without time zone NOT NULL,
    response_time timestamp without time zone NOT NULL,
    duration interval NOT NULL,
    ip_address character varying(45) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ums_request_logs_pkey PRIMARY KEY (id)
);

-- Create the Containers table for managing Kubernetes deployments
CREATE TABLE IF NOT EXISTS ums.ums_containers
(
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL,
    db_host VARCHAR(255) NOT NULL,
    db_port VARCHAR(10) NOT NULL,
    db_name VARCHAR(255) NOT NULL,
    db_user VARCHAR(255) NOT NULL,
    db_password VARCHAR(255) NOT NULL,
    db_username VARCHAR(255) NOT NULL,
    db_password_user VARCHAR(255) NOT NULL,
    external_url VARCHAR(255) NOT NULL DEFAULT '',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Grant necessary permissions for the containers table
--INSERT INTO ums.ums_permissions (role_id, table_name, operation)
--SELECT id, 'ums.containers', 10 -- ALL PRIVILEGES
--FROM ums.ums_roles 
--WHERE role_name = 'superadmin'
--ON CONFLICT DO NOTHING;

ALTER TABLE IF EXISTS ums.ums_user_auth_tokens
    ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;
CREATE INDEX IF NOT EXISTS user_auth_tokens_pkey
    ON ums.ums_user_auth_tokens(id);


ALTER TABLE IF EXISTS ums.ums_user_role
    ADD CONSTRAINT fk_user_role_roles_role_id FOREIGN KEY (role_id)
    REFERENCES ums.ums_roles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_UserRole_RoleId"
    ON ums.ums_user_role(role_id);


ALTER TABLE IF EXISTS ums.ums_user_role
    ADD CONSTRAINT fk_user_role_users_user_id FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_UserRole_UserId"
    ON ums.ums_user_role(user_id);


ALTER TABLE IF EXISTS ums.ums_globalpermissions
    ADD CONSTRAINT fk_role_id FOREIGN KEY (role_id)
    REFERENCES ums.ums_roles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS ums.ums_permissions
    ADD CONSTRAINT fk_role_id FOREIGN KEY (role_id)
    REFERENCES ums.ums_roles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS ums.ums_function_user
    ADD CONSTRAINT function_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_procedure_user
    ADD CONSTRAINT procedure_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_table_user
    ADD CONSTRAINT table_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_trigger_user
    ADD CONSTRAINT trigger_user_fk FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ums.ums_request_logs
    ADD CONSTRAINT fk_user FOREIGN KEY (user_id)
    REFERENCES ums.ums_users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_request_logs_user_id
    ON ums.ums_request_logs(user_id);



CREATE OR REPLACE FUNCTION ums.add_permission_to_role()
RETURNS trigger
LANGUAGE 'plpgsql'
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    schema_name TEXT := 'public'; -- пїЅпїЅпїЅпїЅпїЅ пїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ
    table_name TEXT;
    column_name TEXT;
    full_table_ref TEXT;
BEGIN
    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅ пїЅпїЅ role_id
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = NEW.role_id;

    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ, пїЅпїЅпїЅпїЅ пїЅпїЅ пїЅпїЅпїЅпїЅпїЅ пїЅ пїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ
    IF POSITION('.' IN NEW.table_name) > 0 THEN
        -- table_name пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ 'schema.table' пїЅпїЅпїЅ 'table.column'
        IF NEW.operation IN (0,1,2) AND POSITION('.' IN split_part(NEW.table_name, '.', 2)) > 0 THEN
            -- пїЅпїЅпїЅпїЅпїЅпїЅ: table.column (пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅ)
            table_name := split_part(NEW.table_name, '.', 1);
            column_name := split_part(NEW.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        ELSE
            -- пїЅпїЅпїЅпїЅпїЅпїЅ: schema.table
            schema_name := split_part(NEW.table_name, '.', 1);
            table_name := split_part(NEW.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        END IF;
    ELSE
        -- пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ
        table_name := NEW.table_name;
        full_table_ref := format('%I.%I', schema_name, table_name);
    END IF;

    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ
    IF NEW.operation = 0 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('GRANT INSERT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('GRANT INSERT ON TABLE %s TO %I', full_table_ref, role_name);
        END IF;
    ELSIF NEW.operation = 1 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('GRANT SELECT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('GRANT SELECT ON TABLE %s TO %I', full_table_ref, role_name);
        END IF;
    ELSIF NEW.operation = 2 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('GRANT UPDATE (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('GRANT UPDATE ON TABLE %s TO %I', full_table_ref, role_name);
        END IF;
    ELSIF NEW.operation = 3 THEN
        EXECUTE format('GRANT DELETE ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 4 THEN
        EXECUTE format('GRANT ALTER ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 5 THEN
        EXECUTE format('GRANT DROP ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 6 THEN
        EXECUTE format('GRANT TRIGGER ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 7 THEN
        EXECUTE format('GRANT CREATE ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 8 THEN
        EXECUTE format('GRANT VACUUM ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 9 THEN
        EXECUTE format('GRANT ANALYZE ON TABLE %s TO %I', full_table_ref, role_name);
    ELSIF NEW.operation = 10 THEN
        EXECUTE format('GRANT ALL PRIVILEGES ON TABLE %s TO %I', full_table_ref, role_name);
    END IF;

    RETURN NEW;
END;
$BODY$;



ALTER FUNCTION ums.add_permission_to_role()
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION ums.create_role_from_roles_table()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Check if the role_name is not null
    IF NEW.role_name IS NOT NULL THEN
        -- Create the role with the provided name
        EXECUTE format('CREATE ROLE %I', NEW.role_name);
    END IF;
    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION ums.create_role_from_roles_table()
    OWNER TO postgres;


CREATE OR REPLACE FUNCTION ums.delete_permission_from_role()
RETURNS trigger
LANGUAGE plpgsql
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    schema_name TEXT := 'public'; -- пїЅпїЅпїЅпїЅпїЅ пїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ
    table_name TEXT;
    column_name TEXT;
    full_table_ref TEXT;
BEGIN
    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅ пїЅпїЅ role_id
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = OLD.role_id;

    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅ: column-level пїЅпїЅпїЅ schema.table
    IF POSITION('.' IN OLD.table_name) > 0 THEN
        -- пїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅ пїЅ пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ table.column
        IF OLD.operation IN (0,1,2) AND POSITION('.' IN split_part(OLD.table_name, '.', 2)) > 0 THEN
            -- column-level
            table_name := split_part(OLD.table_name, '.', 1);
            column_name := split_part(OLD.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        ELSE
            -- schema.table
            schema_name := split_part(OLD.table_name, '.', 1);
            table_name := split_part(OLD.table_name, '.', 2);
            full_table_ref := format('%I.%I', schema_name, table_name);
        END IF;
    ELSE
        -- пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ, пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅ
        table_name := OLD.table_name;
        full_table_ref := format('%I.%I', schema_name, table_name);
    END IF;

    -- пїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅ
    IF OLD.operation = 0 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('REVOKE INSERT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('REVOKE INSERT ON TABLE %s FROM %I', full_table_ref, role_name);
        END IF;
    ELSIF OLD.operation = 1 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('REVOKE SELECT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('REVOKE SELECT ON TABLE %s FROM %I', full_table_ref, role_name);
        END IF;
    ELSIF OLD.operation = 2 THEN
        IF column_name IS NOT NULL THEN
            EXECUTE format('REVOKE UPDATE (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            EXECUTE format('REVOKE UPDATE ON TABLE %s FROM %I', full_table_ref, role_name);
        END IF;
    ELSIF OLD.operation = 3 THEN
        EXECUTE format('REVOKE DELETE ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 4 THEN
        EXECUTE format('REVOKE ALTER ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 5 THEN
        EXECUTE format('REVOKE DROP ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 6 THEN
        EXECUTE format('REVOKE TRIGGER ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 7 THEN
        EXECUTE format('REVOKE CREATE ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 8 THEN
        EXECUTE format('REVOKE VACUUM ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 9 THEN
        EXECUTE format('REVOKE ANALYZE ON TABLE %s FROM %I', full_table_ref, role_name);
    ELSIF OLD.operation = 10 THEN
        EXECUTE format('REVOKE ALL PRIVILEGES ON TABLE %s FROM %I', full_table_ref, role_name);
    END IF;

    RETURN OLD;
END;
$BODY$;


ALTER FUNCTION ums.delete_permission_from_role()
    OWNER TO postgres;

-- FUNCTION: ums.delete_role_from_roles_table()
CREATE OR REPLACE FUNCTION ums.delete_role_from_roles_table()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Drop the role if it exists
    EXECUTE format('DROP ROLE IF EXISTS %I', OLD.role_name);
    RETURN OLD;
END;
$BODY$;

ALTER FUNCTION ums.delete_role_from_roles_table()
    OWNER TO postgres;

-- FUNCTION: ums.update_global_role_permissions()
CREATE OR REPLACE FUNCTION ums.update_global_role_permissions()
RETURNS trigger
LANGUAGE plpgsql
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    r RECORD;
BEGIN
    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅ пїЅпїЅ role_id
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = NEW.role_id;

    -- CREATE ON DATABASE (пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅ пїЅпїЅпїЅ, пїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅ пїЅпїЅпїЅпїЅ)
    IF OLD.create_table_grant <> NEW.create_table_grant THEN
        IF OLD.create_table_grant THEN
            EXECUTE format('REVOKE CREATE ON DATABASE %I FROM %I', 'superherodb', role_name);
        END IF;
        IF NEW.create_table_grant THEN
            EXECUTE format('GRANT CREATE ON DATABASE %I TO %I', 'superherodb', role_name);
        END IF;
    END IF;

    -- пїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅ
    FOR r IN
        SELECT schema_name
        FROM information_schema.schemata
        WHERE schema_name NOT IN ('pg_catalog', 'information_schema')
    LOOP
        -- UPDATE ON TABLES
        IF OLD.update_table_grant <> NEW.update_table_grant THEN
            IF OLD.update_table_grant THEN
                EXECUTE format('REVOKE UPDATE ON ALL TABLES IN SCHEMA %I FROM %I', r.schema_name, role_name);
            END IF;
            IF NEW.update_table_grant THEN
                EXECUTE format('GRANT UPDATE ON ALL TABLES IN SCHEMA %I TO %I', r.schema_name, role_name);
            END IF;
        END IF;

        -- DELETE ON TABLES
        IF OLD.delete_table_grant <> NEW.delete_table_grant THEN
            IF OLD.delete_table_grant THEN
                EXECUTE format('REVOKE DELETE ON ALL TABLES IN SCHEMA %I FROM %I', r.schema_name, role_name);
            END IF;
            IF NEW.delete_table_grant THEN
                EXECUTE format('GRANT DELETE ON ALL TABLES IN SCHEMA %I TO %I', r.schema_name, role_name);
            END IF;
        END IF;

        -- CREATE ON SCHEMA
        IF OLD.create_grant <> NEW.create_grant THEN
            IF OLD.create_grant THEN
                EXECUTE format('REVOKE CREATE ON SCHEMA %I FROM %I', r.schema_name, role_name);
            END IF;
            IF NEW.create_grant THEN
                EXECUTE format('GRANT CREATE ON SCHEMA %I TO %I', r.schema_name, role_name);
            END IF;
        END IF;

        -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅ USAGE пїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ (пїЅпїЅпїЅпїЅпїЅ пїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ, пїЅпїЅ пїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ)
    END LOOP;

    RETURN NEW;
END;
$BODY$;


ALTER FUNCTION ums.update_global_role_permissions()
    OWNER TO postgres;

-- FUNCTION: ums.update_role_from_roles_table()
CREATE OR REPLACE FUNCTION ums.update_role_from_roles_table()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Check if the role_name has been modified
    IF OLD.role_name <> NEW.role_name THEN
        -- Check if the old role exists
        PERFORM 1 FROM pg_roles WHERE rolname = OLD.role_name;
        IF FOUND THEN
            -- Rename the old role to the new role
            EXECUTE format('ALTER ROLE %I RENAME TO %I', OLD.role_name, NEW.role_name);
        END IF;
    END IF;
    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION ums.update_role_from_roles_table()
    OWNER TO postgres;

-- FUNCTION: ums.update_role_permissions()
CREATE OR REPLACE FUNCTION ums.update_role_permissions()
RETURNS trigger
LANGUAGE plpgsql
COST 100
VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    role_name TEXT;
    schema_name TEXT := 'public'; -- пїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ
    table_name TEXT;
    column_name TEXT;
    full_table_ref TEXT;
BEGIN
    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅ
    SELECT role_name INTO role_name FROM ums.ums_roles WHERE role_id = NEW.role_id;

    -- пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅ operation пїЅпїЅпїЅ table_name пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ
    IF OLD.operation <> NEW.operation OR OLD.table_name <> NEW.table_name THEN

        ---------------------------------------------------------------------
        -- 1. REVOKE пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅ
        ---------------------------------------------------------------------
        -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅ, пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅ OLD.table_name
        column_name := NULL;
        IF POSITION('.' IN OLD.table_name) > 0 THEN
            IF OLD.operation IN (0,1,2) AND POSITION('.' IN split_part(OLD.table_name, '.', 2)) > 0 THEN
                -- table.column
                table_name := split_part(OLD.table_name, '.', 1);
                column_name := split_part(OLD.table_name, '.', 2);
            ELSE
                -- schema.table
                schema_name := split_part(OLD.table_name, '.', 1);
                table_name := split_part(OLD.table_name, '.', 2);
            END IF;
        ELSE
            table_name := OLD.table_name;
        END IF;
        full_table_ref := format('%I.%I', schema_name, table_name);

        IF OLD.operation = 0 AND column_name IS NOT NULL THEN
            EXECUTE format('REVOKE INSERT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSIF OLD.operation = 1 AND column_name IS NOT NULL THEN
            EXECUTE format('REVOKE SELECT (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSIF OLD.operation = 2 AND column_name IS NOT NULL THEN
            EXECUTE format('REVOKE UPDATE (%I) ON TABLE %s FROM %I', column_name, full_table_ref, role_name);
        ELSE
            CASE OLD.operation
                WHEN 0 THEN EXECUTE format('REVOKE INSERT ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 1 THEN EXECUTE format('REVOKE SELECT ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 2 THEN EXECUTE format('REVOKE UPDATE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 3 THEN EXECUTE format('REVOKE DELETE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 4 THEN EXECUTE format('REVOKE ALTER ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 5 THEN EXECUTE format('REVOKE DROP ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 6 THEN EXECUTE format('REVOKE TRIGGER ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 7 THEN EXECUTE format('REVOKE CREATE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 8 THEN EXECUTE format('REVOKE VACUUM ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 9 THEN EXECUTE format('REVOKE ANALYZE ON TABLE %s FROM %I', full_table_ref, role_name);
                WHEN 10 THEN EXECUTE format('REVOKE ALL PRIVILEGES ON TABLE %s FROM %I', full_table_ref, role_name);
            END CASE;
        END IF;

        ---------------------------------------------------------------------
        -- 2. GRANT пїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅ
        ---------------------------------------------------------------------
        schema_name := 'public'; -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅ пїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ
        column_name := NULL;

        IF POSITION('.' IN NEW.table_name) > 0 THEN
            IF NEW.operation IN (0,1,2) AND POSITION('.' IN split_part(NEW.table_name, '.', 2)) > 0 THEN
                -- table.column
                table_name := split_part(NEW.table_name, '.', 1);
                column_name := split_part(NEW.table_name, '.', 2);
            ELSE
                -- schema.table
                schema_name := split_part(NEW.table_name, '.', 1);
                table_name := split_part(NEW.table_name, '.', 2);
            END IF;
        ELSE
            table_name := NEW.table_name;
        END IF;
        full_table_ref := format('%I.%I', schema_name, table_name);

        IF NEW.operation = 0 AND column_name IS NOT NULL THEN
            EXECUTE format('GRANT INSERT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSIF NEW.operation = 1 AND column_name IS NOT NULL THEN
            EXECUTE format('GRANT SELECT (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSIF NEW.operation = 2 AND column_name IS NOT NULL THEN
            EXECUTE format('GRANT UPDATE (%I) ON TABLE %s TO %I', column_name, full_table_ref, role_name);
        ELSE
            CASE NEW.operation
                WHEN 0 THEN EXECUTE format('GRANT INSERT ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 1 THEN EXECUTE format('GRANT SELECT ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 2 THEN EXECUTE format('GRANT UPDATE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 3 THEN EXECUTE format('GRANT DELETE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 4 THEN EXECUTE format('GRANT ALTER ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 5 THEN EXECUTE format('GRANT DROP ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 6 THEN EXECUTE format('GRANT TRIGGER ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 7 THEN EXECUTE format('GRANT CREATE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 8 THEN EXECUTE format('GRANT VACUUM ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 9 THEN EXECUTE format('GRANT ANALYZE ON TABLE %s TO %I', full_table_ref, role_name);
                WHEN 10 THEN EXECUTE format('GRANT ALL PRIVILEGES ON TABLE %s TO %I', full_table_ref, role_name);
            END CASE;
        END IF;
    END IF;

    RETURN NEW;
END;
$BODY$;


ALTER FUNCTION ums.update_role_permissions()
    OWNER TO postgres;

-- РЎРѕР·РґР°РЅРёРµ РёР»Рё РѕР±РЅРѕРІР»РµРЅРёРµ С‚СЂРёРіРіРµСЂРѕРІ РґР»СЏ С‚Р°Р±Р»РёС†
CREATE OR REPLACE TRIGGER tr_create_role_from_roles_table
    AFTER INSERT
    ON ums.ums_roles
    FOR EACH ROW
    EXECUTE FUNCTION ums.create_role_from_roles_table();

CREATE OR REPLACE TRIGGER tr_update_role_from_roles_table
    AFTER UPDATE
    ON ums.ums_roles
    FOR EACH ROW
    EXECUTE FUNCTION ums.update_role_from_roles_table();

CREATE OR REPLACE TRIGGER tr_delete_role_from_roles_table
    BEFORE DELETE
    ON ums.ums_roles
    FOR EACH ROW
    EXECUTE FUNCTION ums.delete_role_from_roles_table();

CREATE OR REPLACE TRIGGER tr_add_permission_to_role
    AFTER INSERT
    ON ums.ums_permissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.add_permission_to_role();

CREATE OR REPLACE TRIGGER tr_update_role_permissions
    AFTER UPDATE
    ON ums.ums_permissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.update_role_permissions();

CREATE OR REPLACE TRIGGER tr_delete_permission_from_role
    BEFORE DELETE
    ON ums.ums_permissions
    FOR EACH ROW
    EXECUTE FUNCTION ums.delete_permission_from_role();


    CREATE OR REPLACE FUNCTION ums.select_roles(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT json_agg(row_to_json(t)) 
        FROM (
            SELECT
                id as roleid,
                role_name as rolename
            FROM ums.ums_roles
        ) t
    );
END;
$BODY$;

ALTER FUNCTION ums.select_roles()
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.update_roles(
	IN p_roleid integer,
	IN p_rolename text)
LANGUAGE 'plpgsql'
AS $BODY$

    BEGIN
        UPDATE ums.ums_roles
        SET  role_name = p_rolename
        WHERE id = p_roleid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_roles(integer, text)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.delete_roles(
	IN p_roleid integer)
LANGUAGE 'plpgsql'
AS $BODY$

    BEGIN
	DELETE from globalpermissions where roleid=p_roleid;
        DELETE from ums.ums_roles WHERE id = p_roleid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_roles(integer)
    OWNER TO postgres;

    CREATE OR REPLACE FUNCTION ums.select_globalpermissions(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
    BEGIN
        RETURN (SELECT json_agg(row_to_json(t)) FROM (SELECT * FROM ums.ums_globalpermissions) t);
    END;
    
$BODY$;

ALTER FUNCTION ums.select_globalpermissions()
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.insert_globalpermissions(
	IN roleid integer,
	IN create_table_grant boolean,
	IN update_table_grant boolean,
	IN delete_table_grant boolean,
	IN create_grant boolean)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        INSERT INTO ums.ums_globalpermissions (roleid, create_table_grant, update_table_grant, delete_table_grant, create_grant)
        VALUES (roleid, create_table_grant, update_table_grant, delete_table_grant, create_grant);
    END;
    
$BODY$;
ALTER PROCEDURE ums.insert_globalpermissions(integer, boolean, boolean, boolean, boolean)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.update_globalpermissions(
	IN p_permissionid integer,
	IN p_roleid integer,
	IN p_create_table_grant boolean,
	IN p_update_table_grant boolean,
	IN p_delete_table_grant boolean,
	IN p_create_grant boolean)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ, пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅ пїЅ пїЅпїЅпїЅпїЅпїЅ permissionid
    IF EXISTS (SELECT 1 FROM ums.ums_globalpermissions WHERE permissionid = p_permissionid) THEN
        -- пїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ, пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅ
        UPDATE ums.ums_globalpermissions
        SET roleid = p_roleid,
            create_table_grant = p_create_table_grant,
            update_table_grant = p_update_table_grant,
            delete_table_grant = p_delete_table_grant,
            create_grant = p_create_grant
        WHERE permissionid = p_permissionid;
    ELSE
        -- пїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ, пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅ, пїЅпїЅ пїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ p_permissionid, пїЅпїЅпїЅпїЅ пїЅпїЅпїЅ SERIAL
        INSERT INTO ums.ums_globalpermissions (roleid, create_table_grant, update_table_grant, delete_table_grant, create_grant)
        VALUES (p_roleid, p_create_table_grant, p_update_table_grant, p_delete_table_grant, p_create_grant);
    END IF;
END;
    
$BODY$;
ALTER PROCEDURE ums.update_globalpermissions(integer, integer, boolean, boolean, boolean, boolean)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.delete_globalpermissions(
	IN p_roleid integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        delete from ums.ums_globalpermissions WHERE roleid  = p_roleid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_globalpermissions(integer)
    OWNER TO postgres;


    CREATE OR REPLACE FUNCTION ums.select_function_user(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT json_agg(
            json_build_object(
                'id', fu.id,
                'functionname', fu.function_name,
                'userid', fu.user_id,
                'functiondefinition', pg_get_functiondef(p.oid)
            )
        )
        FROM ums.ums_function_user fu
        JOIN pg_proc p ON p.proname = fu.function_name
        JOIN pg_namespace n ON p.pronamespace = n.oid
       
    );
END;
$BODY$;

ALTER FUNCTION ums.select_function_user()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.update_function_user(
	IN p_id integer,
	IN p_user_id integer,
	IN p_function_name character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_function_user
        SET id = p_id, user_id = p_user_id, function_name = p_function_name
        WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_function_user(integer, integer, character varying)
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.delete_function_user(
	IN p_id integer,
	IN p_functionname character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
		DROP function if exists p_functionname;
        DELETE from ums.ums_function_user where id=p_id;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_function_user(integer, character varying)
    OWNER TO postgres;

    CREATE OR REPLACE FUNCTION ums.select_procedure_user(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT json_agg(
            json_build_object(
                'id', fu.id,
                'procedure_name', fu.procedure_name,
                'user_id', fu.user_id,
                'procedure_definition', pg_get_functiondef(p.oid)
            )
        )
        FROM ums.ums_procedure_user fu
        JOIN pg_proc p ON p.proname = fu.procedure_name
        JOIN pg_namespace n ON p.pronamespace = n.oid
    );
END;
$BODY$;

ALTER FUNCTION ums.select_procedure_user()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.update_procedure_user(
	IN p_id integer,
	IN p_user_id integer,
	IN p_procedure_name character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_procedure_user
        SET id = p_id, user_id = p_user_id, procedure_name = p_procedure_name
        WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_procedure_user(integer, integer, character varying)
    OWNER TO postgres;

CREATE OR REPLACE PROCEDURE ums.delete_procedure_user(
    IN p_id integer,
    IN p_procedurename character varying
)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_schema text := 'public';
    v_procname text;
    v_full_name text;
BEGIN
    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ, пїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅ
    IF position('.' in p_procedurename) > 0 THEN
        v_schema := split_part(p_procedurename, '.', 1);
        v_procname := split_part(p_procedurename, '.', 2);
    ELSE
        v_procname := p_procedurename;
    END IF;

    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ
    v_full_name := format('%I.%I', v_schema, v_procname);

    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ (пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ, пїЅпїЅпїЅ пїЅ пїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ)
    EXECUTE format('DROP PROCEDURE IF EXISTS %s', v_full_name);

    -- пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅ
    DELETE FROM procedure_user WHERE id = p_id;
END;
$BODY$;

ALTER PROCEDURE ums.delete_procedure_user(integer, character varying)
    OWNER TO postgres;


    
CREATE OR REPLACE FUNCTION ums.select_table_definition(table_name text)
  RETURNS text
  LANGUAGE plpgsql
AS $BODY$
DECLARE
  reg_oid        oid;
  schema_name    text;
  tbl_name       text;
  table_def      text := '';
  column_def     text;
  constraint_def text;
  comment_text   text;
  row_col        record;
  row_con        record;
  row_idx        record;
  row_comment    record;
BEGIN
  -- Получаем OID, схему и имя таблицы
  SELECT (table_name::regclass)::oid,
         n.nspname,
         c.relname
    INTO reg_oid, schema_name, tbl_name
    FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
   WHERE c.oid = table_name::regclass;

  -- 1) Начало CREATE TABLE
  table_def := format(
    'CREATE TABLE %I.%I (%s',
    schema_name, tbl_name, E'\n'
  );

  -- 1.1) Columns
  FOR row_col IN
    SELECT
      a.attname,
      format_type(a.atttypid, a.atttypmod) AS data_type,
      pg_get_expr(ad.adbin, ad.adrelid)    AS default_value,
      a.attnotnull
    FROM pg_attribute a
    LEFT JOIN pg_attrdef ad
      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
    WHERE a.attrelid = reg_oid
      AND a.attnum > 0
      AND NOT a.attisdropped
    ORDER BY a.attnum
  LOOP
    column_def := format(
      '    %I %s%s%s,',
      row_col.attname,
      row_col.data_type,
      COALESCE(' DEFAULT ' || row_col.default_value, ''),
      CASE WHEN row_col.attnotnull THEN ' NOT NULL' ELSE '' END
    );
    table_def := table_def || column_def || E'\n';
  END LOOP;

  -- 1.2) Constraints (PK, UNIQUE, CHECK, EXCLUDE, FK)
  FOR row_con IN
    SELECT
      c.oid,
      c.conname,
      c.contype,
      c.condeferrable,
      c.condeferred,
      -- Для CHECK
      pg_get_expr(c.conbin, c.conrelid) AS check_expr,
      -- Для FK
      n2.nspname    AS ref_schema,
      c2.relname    AS ref_table,
      c.confmatchtype,
      c.confupdtype,
      c.confdeltype,
      -- Списки ключей
      ARRAY(
        SELECT quote_ident(a2.attname)
        FROM unnest(c.conkey) AS ck(attnum)
        JOIN pg_attribute a2
          ON a2.attrelid = c.conrelid AND a2.attnum = ck.attnum
        ORDER BY array_position(c.conkey, ck.attnum)
      ) AS key_cols,
      ARRAY(
        SELECT quote_ident(a3.attname)
        FROM unnest(c.confkey) AS fk(attnum)
        JOIN pg_attribute a3
          ON a3.attrelid = c.confrelid AND a3.attnum = fk.attnum
        ORDER BY array_position(c.confkey, fk.attnum)
      ) AS ref_cols
    FROM pg_constraint c
    JOIN pg_class rel ON rel.oid = c.conrelid
    JOIN pg_namespace n ON n.oid = rel.relnamespace
    LEFT JOIN pg_class c2 ON c2.oid = c.confrelid
    LEFT JOIN pg_namespace n2 ON n2.oid = c2.relnamespace
    WHERE rel.oid = reg_oid
    ORDER BY c.contype DESC
  LOOP
    constraint_def := '    CONSTRAINT ' || quote_ident(row_con.conname) || ' ';

    IF row_con.contype = 'p' THEN
      constraint_def := constraint_def
        || 'PRIMARY KEY ('
        || array_to_string(row_con.key_cols, ', ')
        || ')';

    ELSIF row_con.contype = 'u' THEN
      constraint_def := constraint_def
        || 'UNIQUE ('
        || array_to_string(row_con.key_cols, ', ')
        || ')';

    ELSIF row_con.contype = 'c' THEN
      constraint_def := constraint_def
        || 'CHECK (' || row_con.check_expr || ')';

    ELSIF row_con.contype = 'x' THEN
      -- EXCLUDE берем целиком через pg_get_constraintdef
      constraint_def := constraint_def
        || substring(
             pg_get_constraintdef(row_con.oid)
             FROM '^EXCLUDE.*'
           );

    ELSIF row_con.contype = 'f' THEN
      constraint_def := constraint_def
        || 'FOREIGN KEY ('
        || array_to_string(row_con.key_cols, ', ')
        || ') REFERENCES '
        || quote_ident(row_con.ref_schema) || '.' || quote_ident(row_con.ref_table)
        || '(' || array_to_string(row_con.ref_cols, ', ') || ')'
        -- MATCH
        || ' MATCH '
        || CASE row_con.confmatchtype
             WHEN 'f' THEN 'FULL'
             WHEN 'p' THEN 'PARTIAL'
             ELSE 'SIMPLE'
           END
        -- ON UPDATE
        || ' ON UPDATE '
        || CASE row_con.confupdtype
             WHEN 'a' THEN 'NO ACTION'
             WHEN 'r' THEN 'RESTRICT'
             WHEN 'c' THEN 'CASCADE'
             WHEN 'n' THEN 'SET NULL'
             WHEN 'd' THEN 'SET DEFAULT'
           END
        -- ON DELETE
        || ' ON DELETE '
        || CASE row_con.confdeltype
             WHEN 'a' THEN 'NO ACTION'
             WHEN 'r' THEN 'RESTRICT'
             WHEN 'c' THEN 'CASCADE'
             WHEN 'n' THEN 'SET NULL'
             WHEN 'd' THEN 'SET DEFAULT'
           END;
    END IF;

    -- DEFERRABLE / INITIALLY ...
    constraint_def := constraint_def
      || CASE WHEN row_con.contype <> 'x'  -- EXCLUDE уже внутри
              THEN
                ' '
                || CASE WHEN row_con.condeferrable THEN 'DEFERRABLE' ELSE 'NOT DEFERRABLE' END
                || ' '
                || CASE WHEN row_con.condeferred THEN 'INITIALLY DEFERRED' ELSE 'INITIALLY IMMEDIATE' END
              ELSE ''
         END
      || ',';

    table_def := table_def || constraint_def || E'\n';
  END LOOP;

  -- Убираем последнюю запятую и закрываем CREATE TABLE
  table_def := regexp_replace(
    table_def,
    ',\s*\n$',
    E'\n',
    'm'
  ) || ');' || E'\n\n';

  -- 2) Комментарии на таблицу
  SELECT obj_description(reg_oid, 'pg_class') INTO comment_text;
  IF comment_text IS NOT NULL THEN
    table_def := table_def
      || format('COMMENT ON TABLE %I.%I IS %L;', schema_name, tbl_name, comment_text)
      || E'\n';
  END IF;

  -- 2.1) Комментарии на столбцы
  FOR row_comment IN
    SELECT a.attname, col_description(a.attrelid, a.attnum) AS comment
      FROM pg_attribute a
     WHERE a.attrelid = reg_oid
       AND a.attnum > 0
       AND NOT a.attisdropped
       AND col_description(a.attrelid,a.attnum) IS NOT NULL
  LOOP
    table_def := table_def
      || format(
           'COMMENT ON COLUMN %I.%I.%I IS %L;',
           schema_name, tbl_name, row_comment.attname,
           row_comment.comment
         ) || E'\n';
  END LOOP;
  table_def := table_def || E'\n';

  -- 3) Индексы
  FOR row_idx IN
    SELECT indexdef
      FROM pg_indexes
     WHERE schemaname = schema_name
       AND tablename  = tbl_name
     ORDER BY indexname
  LOOP
    table_def := table_def || row_idx.indexdef || ';' || E'\n';
  END LOOP;

  RETURN table_def;
END;
$BODY$;



ALTER FUNCTION ums.select_table_definition(text)
    OWNER TO postgres;

    CREATE OR REPLACE FUNCTION ums.select_table_user(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT json_agg(
            json_build_object(
                'id', tu.id,
                'table_name', tu.tablename,
                'user_id', tu.user_id,
                'table_definition', ums.select_table_definition(tu.tablename)
            )
        )
        FROM ums.ums_table_user tu
    );
END;
$BODY$;

ALTER FUNCTION ums.select_table_user()
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.insert_table_user(
	IN id integer,
	IN user_id integer,
	IN tablename character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        INSERT INTO ums.ums_table_user (id, user_id, tablename)
        VALUES (id, user_id, tablename);
    END;
    
$BODY$;
ALTER PROCEDURE ums.insert_table_user(integer, integer, character varying)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.update_table_user(
	IN p_id integer,
	IN p_user_id integer,
	IN p_tablename character varying)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_table_user
        SET id = p_id, user_id = p_user_id, tablename = p_tablename
        WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.update_table_user(integer, integer, character varying)
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.delete_table_user(
	IN p_oid integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_table_user SET deleted_at = now() WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_table_user(integer)
    OWNER TO postgres;

    CREATE OR REPLACE FUNCTION ums.select_trigger_user(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN (
        SELECT json_agg(
            json_build_object(
                'id', tu.id,
                'trigger_name', tu.trigger_name,
                'user_id', tu.user_id,
                'trigger_definition', (
                    SELECT pg_get_triggerdef(t.oid)
                    FROM pg_trigger t
                    JOIN pg_class c ON t.tgrelid = c.oid
                    JOIN pg_namespace n ON c.relnamespace = n.oid
                    WHERE t.tgname = tu.trigger_name
                )
            )
        )
        FROM ums.ums_trigger_user tu
    );
END;
$BODY$;

ALTER FUNCTION ums.select_trigger_user()
    OWNER TO postgres;


    CREATE OR REPLACE FUNCTION ums.select_users(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
    BEGIN
        RETURN (SELECT json_agg(row_to_json(t)) FROM (SELECT id as id, username as username, password_hash as passwordhash FROM ums.ums_users) t);
    END;
    
$BODY$;

ALTER FUNCTION ums.select_users()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.delete_users(
	IN p_oid integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        UPDATE ums.ums_users SET deleted_at = now() WHERE oid = p_oid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_users(integer)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.update_user_auth_tokens(
	IN p_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    UPDATE ums.ums_user_auth_tokens
    SET is_revoked = TRUE,
        revoked_at = NOW()
    WHERE user_id = p_id;
END;
$BODY$;
ALTER PROCEDURE ums.update_user_auth_tokens(integer)
    OWNER TO postgres;


    CREATE OR REPLACE FUNCTION ums.select_userrole(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
    BEGIN
        RETURN (SELECT json_agg(row_to_json(t)) FROM (SELECT id as userroleid, user_id as userid, role_id as roleid FROM ums.ums_user_role) t);
    END;
    
$BODY$;

ALTER FUNCTION ums.select_userrole()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.insert_user_role(
	IN user_id integer,
	IN role_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    INSERT INTO ums.ums_user_role (user_id, role_id)
    VALUES (user_id, role_id);
END;
$BODY$;
ALTER PROCEDURE ums.insert_user_role(integer, integer)
    OWNER TO postgres;

    CREATE OR REPLACE PROCEDURE ums.delete_user_role_by_user_id(
	IN p_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
         DELETE from ums.ums_user_role where user_id=p_id;
    END;
$BODY$;
ALTER PROCEDURE ums.delete_user_role_by_user_id(integer)
    OWNER TO postgres;


    CREATE OR REPLACE FUNCTION ums.select_permissions(
	)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
    BEGIN
        RETURN (SELECT json_agg(row_to_json(t)) FROM (SELECT id as permissionid, role_id as roleid, table_name as tablename, operation as operation  FROM ums.ums_permissions) t);
    END;
    
$BODY$;

ALTER FUNCTION ums.select_permissions()
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.insert_permissions(
	IN roleid integer,
	IN operation integer,
	IN tablename text)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
        INSERT INTO ums.ums_permissions ( role_id, operation, table_name)
        VALUES ( roleid, operation, tablename);
    END;
    
$BODY$;
ALTER PROCEDURE ums.insert_permissions(integer, integer, text)
    OWNER TO postgres;


    CREATE OR REPLACE PROCEDURE ums.delete_permissions(
	IN p_permissionid integer)
LANGUAGE 'plpgsql'
AS $BODY$
    BEGIN
       DELETE FROM ums.ums_permissions WHERE id = p_permissionid;
    END;
    
$BODY$;
ALTER PROCEDURE ums.delete_permissions(integer)
    OWNER TO postgres;


    CREATE OR REPLACE FUNCTION ums.fn_apply_global_permission()
  RETURNS trigger
  LANGUAGE plpgsql
AS $$
DECLARE
  _role_name TEXT;
BEGIN
  -- fetch role name
  SELECT role_name INTO _role_name
    FROM ums.ums_roles
   WHERE id = COALESCE(NEW.role_id, OLD.role_id);

  -- helper to issue GRANT/REVOKE
  IF TG_OP = 'INSERT' THEN
    -- USAGE is almost always desired
    EXECUTE format('GRANT USAGE ON SCHEMA %I TO %I',
                   NEW.schema_name, _role_name);

    IF NEW.grant_create_db THEN
      EXECUTE format('GRANT CREATE ON DATABASE %I TO %I',
                     current_database(), _role_name);
    END IF;
    IF NEW.grant_create_obj THEN
      EXECUTE format('GRANT CREATE ON SCHEMA %I TO %I',
                     NEW.schema_name, _role_name);
    END IF;
    IF NEW.grant_update_tbl THEN
      EXECUTE format('GRANT UPDATE ON ALL TABLES IN SCHEMA %I TO %I',
                     NEW.schema_name, _role_name);
    END IF;
    IF NEW.grant_delete_tbl THEN
      EXECUTE format('GRANT DELETE ON ALL TABLES IN SCHEMA %I TO %I',
                     NEW.schema_name, _role_name);
    END IF;

  ELSIF TG_OP = 'DELETE' THEN
    IF OLD.grant_delete_tbl THEN
      EXECUTE format('REVOKE DELETE ON ALL TABLES IN SCHEMA %I FROM %I',
                     OLD.schema_name, _role_name);
    END IF;
    IF OLD.grant_update_tbl THEN
      EXECUTE format('REVOKE UPDATE ON ALL TABLES IN SCHEMA %I FROM %I',
                     OLD.schema_name, _role_name);
    END IF;
    IF OLD.grant_create_obj THEN
      EXECUTE format('REVOKE CREATE ON SCHEMA %I FROM %I',
                     OLD.schema_name, _role_name);
    END IF;
    IF OLD.grant_create_db THEN
      EXECUTE format('REVOKE CREATE ON DATABASE %I FROM %I',
                     current_database(), _role_name);
    END IF;
    -- finally revoke usage
    EXECUTE format('REVOKE USAGE ON SCHEMA %I FROM %I',
                   OLD.schema_name, _role_name);

  ELSIF TG_OP = 'UPDATE' THEN
    -- handle each privilege if it flipped
    IF OLD.grant_create_db IS DISTINCT FROM NEW.grant_create_db THEN
      EXECUTE format('%s CREATE ON DATABASE %I %s %I',
                     CASE WHEN NEW.grant_create_db THEN 'GRANT' ELSE 'REVOKE' END,
                     current_database(),
                     CASE WHEN NEW.grant_create_db THEN 'TO' ELSE 'FROM' END,
                     _role_name);
    END IF;
    IF OLD.grant_create_obj IS DISTINCT FROM NEW.grant_create_obj THEN
      EXECUTE format('%s CREATE ON SCHEMA %I %s %I',
                     CASE WHEN NEW.grant_create_obj THEN 'GRANT' ELSE 'REVOKE' END,
                     NEW.schema_name,
                     CASE WHEN NEW.grant_create_obj THEN 'TO' ELSE 'FROM' END,
                     _role_name);
    END IF;
    IF OLD.grant_update_tbl IS DISTINCT FROM NEW.grant_update_tbl THEN
      EXECUTE format('%s UPDATE ON ALL TABLES IN SCHEMA %I %s %I',
                     CASE WHEN NEW.grant_update_tbl THEN 'GRANT' ELSE 'REVOKE' END,
                     NEW.schema_name,
                     CASE WHEN NEW.grant_update_tbl THEN 'TO' ELSE 'FROM' END,
                     _role_name);
    END IF;
    IF OLD.grant_delete_tbl IS DISTINCT FROM NEW.grant_delete_tbl THEN
      EXECUTE format('%s DELETE ON ALL TABLES IN SCHEMA %I %s %I',
                     CASE WHEN NEW.grant_delete_tbl THEN 'GRANT' ELSE 'REVOKE' END,
                     NEW.schema_name,
                     CASE WHEN NEW.grant_delete_tbl THEN 'TO' ELSE 'FROM' END,
                     _role_name);
    END IF;
  END IF;

  RETURN COALESCE(NEW, OLD);
END;
$$;

-- 3) Single trigger for all operations
DROP TRIGGER IF EXISTS trg_apply_global_permission
  ON ums.ums_globalpermissions;

CREATE TRIGGER trg_apply_global_permission
  AFTER INSERT OR UPDATE OR DELETE
  ON ums.ums_globalpermissions
  FOR EACH ROW
  EXECUTE FUNCTION ums.fn_apply_global_permission();
END;